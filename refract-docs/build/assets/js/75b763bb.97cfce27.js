"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[647],{5126:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var r=t(6529),a=t(4848),i=t(8453);const s={slug:"performance-optimization-guide",title:"Mastering Performance in Refract - Advanced Optimization Techniques",authors:[{name:"Refract Team",title:"Core Development Team",url:"https://github.com/refract-js",image_url:"/img/logo.svg"}],tags:["performance","optimization","best-practices","advanced"]},o="Mastering Performance in Refract: Advanced Optimization Techniques",l={authorsImageUrls:[void 0]},c=[{value:"Understanding Refract&#39;s Performance Model",id:"understanding-refracts-performance-model",level:2},{value:"Performance Measurement and Profiling",id:"performance-measurement-and-profiling",level:2},{value:"Built-in Performance Monitoring",id:"built-in-performance-monitoring",level:3},{value:"Custom Performance Hooks",id:"custom-performance-hooks",level:3},{value:"Optimizing Refractions",id:"optimizing-refractions",level:2},{value:"1. Minimize Refraction Granularity",id:"1-minimize-refraction-granularity",level:3},{value:"2. Use Derived Values Strategically",id:"2-use-derived-values-strategically",level:3},{value:"3. Batch State Updates",id:"3-batch-state-updates",level:3},{value:"Component-Level Optimizations",id:"component-level-optimizations",level:2},{value:"1. Minimize Component Re-renders",id:"1-minimize-component-re-renders",level:3},{value:"2. Optimize List Rendering",id:"2-optimize-list-rendering",level:3},{value:"3. Lazy Loading and Code Splitting",id:"3-lazy-loading-and-code-splitting",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"1. Cleanup Effects Properly",id:"1-cleanup-effects-properly",level:3},{value:"2. Avoid Memory Leaks in Derived Values",id:"2-avoid-memory-leaks-in-derived-values",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Selective Updates with Lenses",id:"1-selective-updates-with-lenses",level:3},{value:"2. Debounced Updates",id:"2-debounced-updates",level:3},{value:"Performance Monitoring in Production",id:"performance-monitoring-in-production",level:2},{value:"1. Custom Metrics Collection",id:"1-custom-metrics-collection",level:3},{value:"2. Performance Budgets",id:"2-performance-budgets",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={br:"br",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Performance is at the heart of great user experiences. While Refract provides excellent performance out of the box through its reactive architecture, understanding advanced optimization techniques can help you build lightning-fast applications that scale beautifully."}),"\n",(0,a.jsx)(n.h2,{id:"understanding-refracts-performance-model",children:"Understanding Refract's Performance Model"}),"\n",(0,a.jsx)(n.p,{children:"Refract's performance advantages come from several key architectural decisions:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fine-grained reactivity"}),": Only components that depend on changed state re-render"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic batching"}),": Multiple state updates are batched into single render cycles"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intelligent memoization"}),": Derived values are cached and recomputed only when necessary"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Minimal overhead"}),": Lightweight reactive primitives with minimal runtime cost"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"performance-measurement-and-profiling",children:"Performance Measurement and Profiling"}),"\n",(0,a.jsx)(n.p,{children:"Before optimizing, you need to measure. Here's how to profile your Refract applications:"}),"\n",(0,a.jsx)(n.h3,{id:"built-in-performance-monitoring",children:"Built-in Performance Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { createApp, enablePerformanceMonitoring } from 'refract-js';\n\n// Enable performance monitoring in development\nif (process.env.NODE_ENV === 'development') {\n  enablePerformanceMonitoring({\n    logRefractionUpdates: true,\n    logRenderTimes: true,\n    trackMemoryUsage: true,\n  });\n}\n\nconst app = createApp();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"custom-performance-hooks",children:"Custom Performance Hooks"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const usePerformanceTracker = createOptic((lens, componentName) => {\n  const renderCount = lens.useRefraction(0);\n  const lastRenderTime = lens.useRefraction(0);\n\n  lens.useEffect(() => {\n    const start = performance.now();\n    renderCount.set(prev => prev + 1);\n    \n    return () => {\n      const end = performance.now();\n      lastRenderTime.set(end - start);\n      \n      if (process.env.NODE_ENV === 'development') {\n        console.log(`${componentName} render #${renderCount.value}: ${end - start}ms`);\n      }\n    };\n  });\n\n  return {\n    renderCount: renderCount.value,\n    lastRenderTime: lastRenderTime.value,\n  };\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"optimizing-refractions",children:"Optimizing Refractions"}),"\n",(0,a.jsx)(n.h3,{id:"1-minimize-refraction-granularity",children:"1. Minimize Refraction Granularity"}),"\n",(0,a.jsx)(n.p,{children:"Instead of storing complex objects in single refractions, break them down:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u274c Less optimal - entire object updates trigger all dependents\nconst user = lens.useRefraction({\n  profile: { name: 'John', email: 'john@example.com' },\n  preferences: { theme: 'dark', notifications: true },\n  stats: { loginCount: 42, lastLogin: new Date() }\n});\n\n// \u2705 Better - granular updates\nconst userProfile = lens.useRefraction({ name: 'John', email: 'john@example.com' });\nconst userPreferences = lens.useRefraction({ theme: 'dark', notifications: true });\nconst userStats = lens.useRefraction({ loginCount: 42, lastLogin: new Date() });\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-derived-values-strategically",children:"2. Use Derived Values Strategically"}),"\n",(0,a.jsx)(n.p,{children:"Derived values are cached and only recalculated when dependencies change:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const TodoList = createComponent(({ lens, todos }) => {\n  // \u2705 Cached computation - only recalculates when todos change\n  const todoStats = lens.useDerived(() => ({\n    total: todos.value.length,\n    completed: todos.value.filter(t => t.completed).length,\n    active: todos.value.filter(t => !t.completed).length,\n  }), [todos.value]);\n\n  // \u2705 Expensive filtering is cached\n  const filteredTodos = lens.useDerived(() => {\n    return todos.value\n      .filter(todo => todo.text.toLowerCase().includes(searchTerm.value.toLowerCase()))\n      .sort((a, b) => a.priority - b.priority);\n  }, [todos.value, searchTerm.value]);\n\n  return (\n    <div>\n      <TodoStats stats={todoStats.value} />\n      <TodoItems items={filteredTodos.value} />\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-batch-state-updates",children:"3. Batch State Updates"}),"\n",(0,a.jsx)(n.p,{children:"When making multiple related updates, batch them to prevent intermediate renders:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const useOptimizedTodoActions = createOptic((lens, todos) => {\n  const batchUpdateTodos = (updates) => {\n    // Use a single state update for multiple changes\n    todos.set(prevTodos => {\n      let newTodos = [...prevTodos];\n      \n      updates.forEach(update => {\n        switch (update.type) {\n          case 'toggle':\n            newTodos = newTodos.map(todo =>\n              todo.id === update.id ? { ...todo, completed: !todo.completed } : todo\n            );\n            break;\n          case 'delete':\n            newTodos = newTodos.filter(todo => todo.id !== update.id);\n            break;\n          case 'add':\n            newTodos.push(update.todo);\n            break;\n        }\n      });\n      \n      return newTodos;\n    });\n  };\n\n  const completeAll = () => {\n    todos.set(prevTodos => \n      prevTodos.map(todo => ({ ...todo, completed: true }))\n    );\n  };\n\n  return { batchUpdateTodos, completeAll };\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"component-level-optimizations",children:"Component-Level Optimizations"}),"\n",(0,a.jsx)(n.h3,{id:"1-minimize-component-re-renders",children:"1. Minimize Component Re-renders"}),"\n",(0,a.jsx)(n.p,{children:"Use component memoization for expensive renders:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ExpensiveChart = createComponent(({ lens, data, config }) => {\n  // Only re-render when data or config actually changes\n  const memoizedChart = lens.useDerived(() => {\n    return generateChartData(data.value, config.value);\n  }, [data.value, config.value]);\n\n  // Expensive DOM operations only when necessary\n  lens.useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    renderChart(ctx, memoizedChart.value);\n  }, [memoizedChart.value]);\n\n  return <canvas ref={canvasRef} />;\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-optimize-list-rendering",children:"2. Optimize List Rendering"}),"\n",(0,a.jsx)(n.p,{children:"For large lists, implement virtualization and efficient key strategies:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const VirtualizedList = createComponent(({ lens, items, itemHeight = 50 }) => {\n  const scrollTop = lens.useRefraction(0);\n  const containerHeight = lens.useRefraction(400);\n\n  const visibleItems = lens.useDerived(() => {\n    const startIndex = Math.floor(scrollTop.value / itemHeight);\n    const endIndex = Math.min(\n      startIndex + Math.ceil(containerHeight.value / itemHeight) + 1,\n      items.value.length\n    );\n    \n    return items.value.slice(startIndex, endIndex).map((item, index) => ({\n      ...item,\n      index: startIndex + index,\n    }));\n  }, [scrollTop.value, containerHeight.value, items.value]);\n\n  const totalHeight = items.value.length * itemHeight;\n  const offsetY = Math.floor(scrollTop.value / itemHeight) * itemHeight;\n\n  return (\n    <div \n      style={{ height: containerHeight.value, overflow: 'auto' }}\n      onScroll={(e) => scrollTop.set(e.target.scrollTop)}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${offsetY}px)` }}>\n          {visibleItems.value.map(item => (\n            <ListItem \n              key={item.id} \n              item={item} \n              style={{ height: itemHeight }}\n            />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-lazy-loading-and-code-splitting",children:"3. Lazy Loading and Code Splitting"}),"\n",(0,a.jsx)(n.p,{children:"Implement lazy loading for better initial load performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const LazyRoute = createComponent(({ lens, path, component: Component }) => {\n  const isLoaded = lens.useRefraction(false);\n  const loadedComponent = lens.useRefraction(null);\n\n  lens.useEffect(() => {\n    if (path === currentPath.value && !isLoaded.value) {\n      Component().then(module => {\n        loadedComponent.set(module.default);\n        isLoaded.set(true);\n      });\n    }\n  }, [path, currentPath.value]);\n\n  if (!isLoaded.value) {\n    return <LoadingSpinner />;\n  }\n\n  const LoadedComponent = loadedComponent.value;\n  return LoadedComponent ? <LoadedComponent lens={lens} /> : null;\n});\n\n// Usage\nconst routes = [\n  { path: '/dashboard', component: () => import('./Dashboard') },\n  { path: '/profile', component: () => import('./Profile') },\n  { path: '/settings', component: () => import('./Settings') },\n];\n"})}),"\n",(0,a.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.h3,{id:"1-cleanup-effects-properly",children:"1. Cleanup Effects Properly"}),"\n",(0,a.jsx)(n.p,{children:"Always clean up subscriptions and timers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const useWebSocketConnection = createOptic((lens, url) => {\n  const connection = lens.useRefraction(null);\n  const messages = lens.useRefraction([]);\n\n  lens.useEffect(() => {\n    const ws = new WebSocket(url);\n    \n    ws.onmessage = (event) => {\n      messages.set(prev => [...prev, JSON.parse(event.data)]);\n    };\n    \n    connection.set(ws);\n    \n    // Cleanup function\n    return () => {\n      ws.close();\n      connection.set(null);\n    };\n  }, [url]);\n\n  return {\n    connection: connection.value,\n    messages: messages.value,\n  };\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-avoid-memory-leaks-in-derived-values",children:"2. Avoid Memory Leaks in Derived Values"}),"\n",(0,a.jsx)(n.p,{children:"Be careful with closures in derived values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u274c Potential memory leak - captures entire component scope\nconst expensiveComputation = lens.useDerived(() => {\n  return heavyProcessing(someData, anotherData, yetAnotherData);\n}, [someData.value]);\n\n// \u2705 Better - only capture what's needed\nconst expensiveComputation = lens.useDerived(() => {\n  const data = someData.value;\n  return heavyProcessing(data);\n}, [someData.value]);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"1-selective-updates-with-lenses",children:"1. Selective Updates with Lenses"}),"\n",(0,a.jsx)(n.p,{children:"Use lenses to update specific parts of complex state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const useSelectiveUpdates = createOptic((lens, initialState) => {\n  const state = lens.useRefraction(initialState);\n\n  const updatePath = (path, value) => {\n    state.set(prevState => {\n      const newState = { ...prevState };\n      let current = newState;\n      \n      for (let i = 0; i < path.length - 1; i++) {\n        current[path[i]] = { ...current[path[i]] };\n        current = current[path[i]];\n      }\n      \n      current[path[path.length - 1]] = value;\n      return newState;\n    });\n  };\n\n  return {\n    state: state.value,\n    updatePath,\n  };\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-debounced-updates",children:"2. Debounced Updates"}),"\n",(0,a.jsx)(n.p,{children:"Implement debouncing for expensive operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const useDebouncedSearch = createOptic((lens, delay = 300) => {\n  const query = lens.useRefraction('');\n  const debouncedQuery = lens.useRefraction('');\n  const isSearching = lens.useRefraction(false);\n\n  lens.useEffect(() => {\n    const timer = setTimeout(() => {\n      debouncedQuery.set(query.value);\n      isSearching.set(false);\n    }, delay);\n\n    isSearching.set(true);\n\n    return () => clearTimeout(timer);\n  }, [query.value, delay]);\n\n  return {\n    query: query.value,\n    debouncedQuery: debouncedQuery.value,\n    isSearching: isSearching.value,\n    setQuery: query.set,\n  };\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-monitoring-in-production",children:"Performance Monitoring in Production"}),"\n",(0,a.jsx)(n.h3,{id:"1-custom-metrics-collection",children:"1. Custom Metrics Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const usePerformanceMetrics = createOptic((lens) => {\n  const metrics = lens.useRefraction({\n    renderCount: 0,\n    averageRenderTime: 0,\n    memoryUsage: 0,\n  });\n\n  const recordRender = (renderTime) => {\n    metrics.set(prev => ({\n      renderCount: prev.renderCount + 1,\n      averageRenderTime: (prev.averageRenderTime * prev.renderCount + renderTime) / (prev.renderCount + 1),\n      memoryUsage: performance.memory?.usedJSHeapSize || 0,\n    }));\n  };\n\n  // Send metrics to analytics service\n  lens.useEffect(() => {\n    const interval = setInterval(() => {\n      if (metrics.value.renderCount > 0) {\n        analytics.track('performance_metrics', metrics.value);\n      }\n    }, 60000); // Every minute\n\n    return () => clearInterval(interval);\n  }, []);\n\n  return { metrics: metrics.value, recordRender };\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-performance-budgets",children:"2. Performance Budgets"}),"\n",(0,a.jsx)(n.p,{children:"Set up performance budgets and alerts:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const PERFORMANCE_BUDGETS = {\n  maxRenderTime: 16, // 60fps\n  maxMemoryUsage: 50 * 1024 * 1024, // 50MB\n  maxRefractionUpdates: 100, // per second\n};\n\nconst usePerformanceBudget = createOptic((lens) => {\n  const violations = lens.useRefraction([]);\n\n  const checkBudget = (metric, value) => {\n    const budget = PERFORMANCE_BUDGETS[metric];\n    if (budget && value > budget) {\n      violations.set(prev => [...prev, {\n        metric,\n        value,\n        budget,\n        timestamp: Date.now(),\n      }]);\n\n      // Alert in development\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`Performance budget exceeded: ${metric} (${value} > ${budget})`);\n      }\n    }\n  };\n\n  return { violations: violations.value, checkBudget };\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Measure First"}),": Always profile before optimizing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Granular State"}),": Break down complex state into smaller refractions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache Expensive Operations"}),": Use derived values for computations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Updates"}),": Group related state changes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clean Up"}),": Always clean up effects and subscriptions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Virtualize Large Lists"}),": Implement virtualization for performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lazy Load"}),": Split code and load components on demand"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitor Production"}),": Track performance metrics in production"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Refract's reactive architecture provides excellent performance out of the box, but understanding these advanced optimization techniques will help you build applications that scale to millions of users while maintaining smooth, responsive user experiences."}),"\n",(0,a.jsx)(n.p,{children:"Remember: premature optimization is the root of all evil. Focus on building great features first, then optimize based on real performance data and user feedback."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Happy optimizing!"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.em,{children:"The Refract Team"})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},6529:e=>{e.exports=JSON.parse('{"permalink":"/blog/performance-optimization-guide","editUrl":"https://github.com/refract-js/refract/tree/main/docs/blog/2024-02-28-performance-optimization-guide.md","source":"@site/blog/2024-02-28-performance-optimization-guide.md","title":"Mastering Performance in Refract - Advanced Optimization Techniques","description":"Performance is at the heart of great user experiences. While Refract provides excellent performance out of the box through its reactive architecture, understanding advanced optimization techniques can help you build lightning-fast applications that scale beautifully.","date":"2024-02-28T00:00:00.000Z","tags":[{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"optimization","permalink":"/blog/tags/optimization"},{"inline":true,"label":"best-practices","permalink":"/blog/tags/best-practices"},{"inline":true,"label":"advanced","permalink":"/blog/tags/advanced"}],"readingTime":5.69,"hasTruncateMarker":true,"authors":[{"name":"Refract Team","title":"Core Development Team","url":"https://github.com/refract-js","image_url":"/img/logo.svg","imageURL":"/img/logo.svg","socials":{},"key":null,"page":null}],"frontMatter":{"slug":"performance-optimization-guide","title":"Mastering Performance in Refract - Advanced Optimization Techniques","authors":[{"name":"Refract Team","title":"Core Development Team","url":"https://github.com/refract-js","image_url":"/img/logo.svg","imageURL":"/img/logo.svg"}],"tags":["performance","optimization","best-practices","advanced"]},"unlisted":false,"nextItem":{"title":"Introducing Refract - A New Era of Reactive UI Development","permalink":"/blog/introducing-refract"}}')},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);