"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[2458],{6674:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=t(4848),r=t(8453);const a={},i="Optics",o={id:"concepts/optics",title:"Optics",description:"Optics are Refract's composable logic units that encapsulate reusable patterns and behaviors. They're similar to React hooks but designed specifically for Refract's reactive system, providing a clean way to share stateful logic between components while maintaining proper reactivity and lifecycle management.",source:"@site/docs/concepts/optics.md",sourceDirName:"concepts",slug:"/concepts/optics",permalink:"/docs/concepts/optics",draft:!1,unlisted:!1,editUrl:"https://github.com/refract-js/refract/tree/main/docs/docs/concepts/optics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lenses",permalink:"/docs/concepts/lenses"},next:{title:"Effects",permalink:"/docs/concepts/effects"}},c={},l=[{value:"What are Optics?",id:"what-are-optics",level:2},{value:"Creating Optics",id:"creating-optics",level:2},{value:"Basic Optic Structure",id:"basic-optic-structure",level:3},{value:"Optics with Side Effects",id:"optics-with-side-effects",level:3},{value:"Advanced Optic Patterns",id:"advanced-optic-patterns",level:2},{value:"Async Data Fetching",id:"async-data-fetching",level:3},{value:"Form Management",id:"form-management",level:3},{value:"Animation and Transitions",id:"animation-and-transitions",level:3},{value:"Optic Composition",id:"optic-composition",level:2},{value:"Combining Multiple Optics",id:"combining-multiple-optics",level:3},{value:"Higher-Order Optics",id:"higher-order-optics",level:3},{value:"Testing Optics",id:"testing-optics",level:2},{value:"Unit Testing Optics",id:"unit-testing-optics",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Optics Focused",id:"1-keep-optics-focused",level:3},{value:"2. Use Descriptive Names",id:"2-use-descriptive-names",level:3},{value:"3. Handle Edge Cases",id:"3-handle-edge-cases",level:3},{value:"4. Provide Cleanup",id:"4-provide-cleanup",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"optics",children:"Optics"}),"\n",(0,s.jsx)(n.p,{children:"Optics are Refract's composable logic units that encapsulate reusable patterns and behaviors. They're similar to React hooks but designed specifically for Refract's reactive system, providing a clean way to share stateful logic between components while maintaining proper reactivity and lifecycle management."}),"\n",(0,s.jsx)(n.h2,{id:"what-are-optics",children:"What are Optics?"}),"\n",(0,s.jsx)(n.p,{children:"An optic is a reusable function that encapsulates reactive logic, state management, and side effects. Optics can be composed together to create complex behaviors from simple, testable units."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { createOptic } from 'refract';\n\n// Basic optic for counter logic\nconst useCounter = createOptic((initialValue = 0) => {\n  const count = useRefraction(initialValue);\n  \n  const increment = () => count.set(count.value + 1);\n  const decrement = () => count.set(count.value - 1);\n  const reset = () => count.set(initialValue);\n  \n  return {\n    count: count.value,\n    increment,\n    decrement,\n    reset\n  };\n});\n\n// Using the optic in a component\nconst Counter = createComponent(({ lens }) => {\n  const counter = lens.useOptic(() => useCounter(0), []);\n  \n  return (\n    <div>\n      <p>Count: {counter.count}</p>\n      <button onClick={counter.decrement}>-</button>\n      <button onClick={counter.reset}>Reset</button>\n      <button onClick={counter.increment}>+</button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-optics",children:"Creating Optics"}),"\n",(0,s.jsx)(n.h3,{id:"basic-optic-structure",children:"Basic Optic Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { createOptic, useRefraction, useEffect } from 'refract';\n\nconst useToggle = createOptic((initialValue = false) => {\n  const isToggled = useRefraction(initialValue);\n  \n  const toggle = () => isToggled.set(!isToggled.value);\n  const setToggle = (value) => isToggled.set(value);\n  \n  return {\n    isToggled: isToggled.value,\n    toggle,\n    setToggle\n  };\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optics-with-side-effects",children:"Optics with Side Effects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const useLocalStorage = createOptic((key, defaultValue) => {\n  // Initialize from localStorage\n  const getStoredValue = () => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error);\n      return defaultValue;\n    }\n  };\n  \n  const storedValue = useRefraction(getStoredValue());\n  \n  // Sync to localStorage when value changes\n  useEffect(() => {\n    try {\n      localStorage.setItem(key, JSON.stringify(storedValue.value));\n    } catch (error) {\n      console.warn(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [storedValue.value, key]);\n  \n  return {\n    value: storedValue.value,\n    setValue: storedValue.set\n  };\n});\n\n// Usage\nconst Settings = createComponent(({ lens }) => {\n  const theme = lens.useOptic(() => useLocalStorage('theme', 'light'), []);\n  \n  return (\n    <div>\n      <p>Current theme: {theme.value}</p>\n      <button onClick={() => theme.setValue(theme.value === 'light' ? 'dark' : 'light')}>\n        Toggle Theme\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-optic-patterns",children:"Advanced Optic Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"async-data-fetching",children:"Async Data Fetching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const useFetch = createOptic((url, options = {}) => {\n  const data = useRefraction(null);\n  const loading = useRefraction(false);\n  const error = useRefraction(null);\n  \n  const fetchData = async () => {\n    loading.set(true);\n    error.set(null);\n    \n    try {\n      const response = await fetch(url, options);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      data.set(result);\n    } catch (err) {\n      error.set(err.message);\n    } finally {\n      loading.set(false);\n    }\n  };\n  \n  // Auto-fetch on mount and when URL changes\n  useEffect(() => {\n    fetchData();\n  }, [url]);\n  \n  return {\n    data: data.value,\n    loading: loading.value,\n    error: error.value,\n    refetch: fetchData\n  };\n});\n\n// Usage\nconst UserProfile = createComponent(({ lens, userId }) => {\n  const { data: user, loading, error, refetch } = lens.useOptic(\n    () => useFetch(`/api/users/${userId}`),\n    [userId]\n  );\n  \n  if (loading) return <div>Loading user...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <div>\n      <h2>{user?.name}</h2>\n      <p>{user?.email}</p>\n      <button onClick={refetch}>Refresh</button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"form-management",children:"Form Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const useForm = createOptic((initialValues, validationSchema = {}) => {\n  const values = useRefraction(initialValues);\n  const errors = useRefraction({});\n  const touched = useRefraction({});\n  const isSubmitting = useRefraction(false);\n  \n  const setValue = (field, value) => {\n    values.set(prev => ({ ...prev, [field]: value }));\n    \n    // Clear error when user starts typing\n    if (errors.value[field]) {\n      errors.set(prev => ({ ...prev, [field]: null }));\n    }\n  };\n  \n  const setTouched = (field) => {\n    touched.set(prev => ({ ...prev, [field]: true }));\n  };\n  \n  const validate = () => {\n    const newErrors = {};\n    \n    Object.keys(validationSchema).forEach(field => {\n      const rules = validationSchema[field];\n      const value = values.value[field];\n      \n      if (rules.required && (!value || value.toString().trim() === '')) {\n        newErrors[field] = `${field} is required`;\n        return;\n      }\n      \n      if (rules.minLength && value && value.length < rules.minLength) {\n        newErrors[field] = `${field} must be at least ${rules.minLength} characters`;\n        return;\n      }\n      \n      if (rules.pattern && value && !rules.pattern.test(value)) {\n        newErrors[field] = rules.message || `${field} format is invalid`;\n        return;\n      }\n    });\n    \n    errors.set(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n  \n  const handleSubmit = async (onSubmit) => {\n    // Mark all fields as touched\n    const allFields = Object.keys(initialValues);\n    const touchedState = {};\n    allFields.forEach(field => touchedState[field] = true);\n    touched.set(touchedState);\n    \n    if (!validate()) {\n      return;\n    }\n    \n    isSubmitting.set(true);\n    \n    try {\n      await onSubmit(values.value);\n    } catch (error) {\n      console.error('Form submission error:', error);\n    } finally {\n      isSubmitting.set(false);\n    }\n  };\n  \n  const reset = () => {\n    values.set(initialValues);\n    errors.set({});\n    touched.set({});\n    isSubmitting.set(false);\n  };\n  \n  return {\n    values: values.value,\n    errors: errors.value,\n    touched: touched.value,\n    isSubmitting: isSubmitting.value,\n    setValue,\n    setTouched,\n    validate,\n    handleSubmit,\n    reset\n  };\n});\n\n// Usage\nconst ContactForm = createComponent(({ lens }) => {\n  const form = lens.useOptic(() => useForm(\n    { name: '', email: '', message: '' },\n    {\n      name: { required: true, minLength: 2 },\n      email: { \n        required: true, \n        pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n        message: 'Please enter a valid email address'\n      },\n      message: { required: true, minLength: 10 }\n    }\n  ), []);\n  \n  const onSubmit = async (data) => {\n    await fetch('/api/contact', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    \n    form.reset();\n    alert('Message sent successfully!');\n  };\n  \n  return (\n    <form onSubmit={(e) => {\n      e.preventDefault();\n      form.handleSubmit(onSubmit);\n    }}>\n      <div>\n        <input\n          value={form.values.name}\n          onChange={(e) => form.setValue('name', e.target.value)}\n          onBlur={() => form.setTouched('name')}\n          placeholder=\"Name\"\n          className={form.touched.name && form.errors.name ? 'error' : ''}\n        />\n        {form.touched.name && form.errors.name && (\n          <span className=\"error-message\">{form.errors.name}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          type=\"email\"\n          value={form.values.email}\n          onChange={(e) => form.setValue('email', e.target.value)}\n          onBlur={() => form.setTouched('email')}\n          placeholder=\"Email\"\n          className={form.touched.email && form.errors.email ? 'error' : ''}\n        />\n        {form.touched.email && form.errors.email && (\n          <span className=\"error-message\">{form.errors.email}</span>\n        )}\n      </div>\n      \n      <div>\n        <textarea\n          value={form.values.message}\n          onChange={(e) => form.setValue('message', e.target.value)}\n          onBlur={() => form.setTouched('message')}\n          placeholder=\"Message\"\n          className={form.touched.message && form.errors.message ? 'error' : ''}\n        />\n        {form.touched.message && form.errors.message && (\n          <span className=\"error-message\">{form.errors.message}</span>\n        )}\n      </div>\n      \n      <button type=\"submit\" disabled={form.isSubmitting}>\n        {form.isSubmitting ? 'Sending...' : 'Send Message'}\n      </button>\n    </form>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"animation-and-transitions",children:"Animation and Transitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const useAnimation = createOptic((duration = 300, easing = 'ease-out') => {\n  const isAnimating = useRefraction(false);\n  const progress = useRefraction(0);\n  \n  const animate = (from, to, onUpdate) => {\n    return new Promise((resolve) => {\n      isAnimating.set(true);\n      progress.set(0);\n      \n      const startTime = Date.now();\n      const difference = to - from;\n      \n      const tick = () => {\n        const elapsed = Date.now() - startTime;\n        const normalizedProgress = Math.min(elapsed / duration, 1);\n        \n        // Apply easing\n        let easedProgress;\n        switch (easing) {\n          case 'ease-in':\n            easedProgress = normalizedProgress * normalizedProgress;\n            break;\n          case 'ease-out':\n            easedProgress = 1 - Math.pow(1 - normalizedProgress, 2);\n            break;\n          default:\n            easedProgress = normalizedProgress;\n        }\n        \n        progress.set(easedProgress);\n        const currentValue = from + (difference * easedProgress);\n        onUpdate(currentValue);\n        \n        if (normalizedProgress < 1) {\n          requestAnimationFrame(tick);\n        } else {\n          isAnimating.set(false);\n          resolve();\n        }\n      };\n      \n      requestAnimationFrame(tick);\n    });\n  };\n  \n  return {\n    isAnimating: isAnimating.value,\n    progress: progress.value,\n    animate\n  };\n});\n\n// Usage\nconst AnimatedCounter = createComponent(({ lens, target }) => {\n  const displayValue = lens.useRefraction(0);\n  const animation = lens.useOptic(() => useAnimation(1000, 'ease-out'), []);\n  \n  lens.useEffect(() => {\n    animation.animate(\n      displayValue.value,\n      target,\n      (value) => displayValue.set(Math.round(value))\n    );\n  }, [target]);\n  \n  return (\n    <div className=\"animated-counter\">\n      <span className=\"counter-value\">{displayValue.value}</span>\n      {animation.isAnimating && (\n        <div className=\"progress-bar\">\n          <div \n            className=\"progress-fill\"\n            style={{ width: `${animation.progress * 100}%` }}\n          />\n        </div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"optic-composition",children:"Optic Composition"}),"\n",(0,s.jsx)(n.h3,{id:"combining-multiple-optics",children:"Combining Multiple Optics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const useUserDashboard = createOptic((userId) => {\n  // Compose multiple optics\n  const user = useFetch(`/api/users/${userId}`);\n  const posts = useFetch(`/api/users/${userId}/posts`);\n  const settings = useLocalStorage(`user-${userId}-settings`, {});\n  \n  const isLoading = user.loading || posts.loading;\n  const hasError = user.error || posts.error;\n  \n  const refreshAll = () => {\n    user.refetch();\n    posts.refetch();\n  };\n  \n  return {\n    user: user.data,\n    posts: posts.data,\n    settings: settings.value,\n    updateSettings: settings.setValue,\n    isLoading,\n    hasError,\n    refreshAll\n  };\n});\n\n// Usage\nconst UserDashboard = createComponent(({ lens, userId }) => {\n  const dashboard = lens.useOptic(() => useUserDashboard(userId), [userId]);\n  \n  if (dashboard.isLoading) return <div>Loading dashboard...</div>;\n  if (dashboard.hasError) return <div>Error loading dashboard</div>;\n  \n  return (\n    <div className="user-dashboard">\n      <header>\n        <h1>Welcome, {dashboard.user?.name}</h1>\n        <button onClick={dashboard.refreshAll}>Refresh</button>\n      </header>\n      \n      <section>\n        <h2>Recent Posts</h2>\n        {dashboard.posts?.map(post => (\n          <article key={post.id}>\n            <h3>{post.title}</h3>\n            <p>{post.excerpt}</p>\n          </article>\n        ))}\n      </section>\n    </div>\n  );\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"higher-order-optics",children:"Higher-Order Optics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const withRetry = (optic, maxRetries = 3) => {\n  return createOptic((...args) => {\n    const result = optic(...args);\n    const retryCount = useRefraction(0);\n    \n    const retryOperation = async () => {\n      if (retryCount.value < maxRetries) {\n        retryCount.set(retryCount.value + 1);\n        if (result.refetch) {\n          await result.refetch();\n        }\n      }\n    };\n    \n    return {\n      ...result,\n      retryCount: retryCount.value,\n      canRetry: retryCount.value < maxRetries,\n      retry: retryOperation\n    };\n  });\n};\n\n// Usage\nconst useReliableFetch = withRetry(useFetch, 3);\n\nconst ReliableDataComponent = createComponent(({ lens, url }) => {\n  const { data, loading, error, canRetry, retry } = lens.useOptic(\n    () => useReliableFetch(url),\n    [url]\n  );\n  \n  if (loading) return <div>Loading...</div>;\n  \n  if (error) {\n    return (\n      <div>\n        <p>Error: {error}</p>\n        {canRetry && (\n          <button onClick={retry}>Retry</button>\n        )}\n      </div>\n    );\n  }\n  \n  return <div>{JSON.stringify(data)}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-optics",children:"Testing Optics"}),"\n",(0,s.jsx)(n.h3,{id:"unit-testing-optics",children:"Unit Testing Optics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// optics/useCounter.test.js\nimport { renderOptic } from '@refract/testing-utils';\nimport { useCounter } from './useCounter';\n\ndescribe('useCounter', () => {\n  test('initializes with default value', () => {\n    const { result } = renderOptic(() => useCounter());\n    \n    expect(result.current.count).toBe(0);\n  });\n  \n  test('initializes with custom value', () => {\n    const { result } = renderOptic(() => useCounter(5));\n    \n    expect(result.current.count).toBe(5);\n  });\n  \n  test('increments count', () => {\n    const { result } = renderOptic(() => useCounter(0));\n    \n    result.current.increment();\n    \n    expect(result.current.count).toBe(1);\n  });\n  \n  test('decrements count', () => {\n    const { result } = renderOptic(() => useCounter(5));\n    \n    result.current.decrement();\n    \n    expect(result.current.count).toBe(4);\n  });\n  \n  test('resets to initial value', () => {\n    const { result } = renderOptic(() => useCounter(10));\n    \n    result.current.increment();\n    result.current.increment();\n    expect(result.current.count).toBe(12);\n    \n    result.current.reset();\n    expect(result.current.count).toBe(10);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/Counter.test.js\nimport { render, fireEvent } from '@refract/testing-utils';\nimport { Counter } from './Counter';\n\ndescribe('Counter Component', () => {\n  test('displays initial count and responds to clicks', () => {\n    const { getByText, getByRole } = render(<Counter />);\n    \n    expect(getByText('Count: 0')).toBeInTheDocument();\n    \n    fireEvent.click(getByRole('button', { name: '+' }));\n    expect(getByText('Count: 1')).toBeInTheDocument();\n    \n    fireEvent.click(getByRole('button', { name: '-' }));\n    expect(getByText('Count: 0')).toBeInTheDocument();\n    \n    fireEvent.click(getByRole('button', { name: 'Reset' }));\n    expect(getByText('Count: 0')).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-keep-optics-focused",children:"1. Keep Optics Focused"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Single responsibility\nconst useCounter = createOptic((initialValue = 0) => {\n  // Only counter logic\n});\n\nconst useTimer = createOptic(() => {\n  // Only timer logic\n});\n\n// \u274c Bad - Multiple responsibilities\nconst useCounterAndTimer = createOptic(() => {\n  // Counter and timer logic mixed together\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-use-descriptive-names",children:"2. Use Descriptive Names"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nconst useUserAuthentication = createOptic(() => { /* ... */ });\nconst useShoppingCart = createOptic(() => { /* ... */ });\nconst useFormValidation = createOptic(() => { /* ... */ });\n\n// \u274c Bad\nconst useData = createOptic(() => { /* ... */ });\nconst useStuff = createOptic(() => { /* ... */ });\nconst useHelper = createOptic(() => { /* ... */ });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-handle-edge-cases",children:"3. Handle Edge Cases"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const useSafeLocalStorage = createOptic((key, defaultValue) => {\n  const getValue = () => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n      console.warn(`Failed to parse localStorage item "${key}":`, error);\n      return defaultValue;\n    }\n  };\n  \n  const value = useRefraction(getValue());\n  \n  const setValue = (newValue) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(newValue));\n      value.set(newValue);\n    } catch (error) {\n      console.error(`Failed to set localStorage item "${key}":`, error);\n    }\n  };\n  \n  return { value: value.value, setValue };\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-provide-cleanup",children:"4. Provide Cleanup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const useWebSocket = createOptic((url) => {\n  const messages = useRefraction([]);\n  const connectionStatus = useRefraction('connecting');\n  \n  useEffect(() => {\n    const ws = new WebSocket(url);\n    \n    ws.onopen = () => connectionStatus.set('connected');\n    ws.onclose = () => connectionStatus.set('disconnected');\n    ws.onmessage = (event) => {\n      messages.set(prev => [...prev, JSON.parse(event.data)]);\n    };\n    \n    // Cleanup on unmount\n    return () => {\n      ws.close();\n    };\n  }, [url]);\n  \n  return {\n    messages: messages.value,\n    connectionStatus: connectionStatus.value\n  };\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand optics, explore:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./effects",children:"Effects"})})," - Advanced side effect management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../api/overview",children:"API Reference"})})," - Complete API documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../tutorials/counter-app",children:"Tutorials"})})," - Practical examples using optics"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);