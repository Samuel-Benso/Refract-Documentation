"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[6668],{2606:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(4848),a=t(8453);const o={},r="useLens",i={id:"api/useLens",title:"useLens",description:"The useLens hook provides access to the lens system within Refract components. The lens is the primary interface for accessing reactive features like state management, effects, and optics in a component-scoped manner.",source:"@site/docs/api/useLens.md",sourceDirName:"api",slug:"/api/useLens",permalink:"/docs/api/useLens",draft:!1,unlisted:!1,editUrl:"https://github.com/refract-js/refract/tree/main/docs/docs/api/useLens.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useFlash",permalink:"/docs/api/useFlash"},next:{title:"Building a Counter App",permalink:"/docs/tutorials/counter-app"}},c={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Accessing the Lens",id:"accessing-the-lens",level:3},{value:"Alternative: Destructured Props",id:"alternative-destructured-props",level:3},{value:"Lens Methods",id:"lens-methods",level:2},{value:"State Management",id:"state-management",level:3},{value:"Effect Management",id:"effect-management",level:3},{value:"Optic Usage",id:"optic-usage",level:3},{value:"Batching Updates",id:"batching-updates",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Complex Batching",id:"complex-batching",level:3},{value:"Lens Composition Patterns",id:"lens-composition-patterns",level:2},{value:"Custom Lens Wrapper",id:"custom-lens-wrapper",level:3},{value:"Lens Provider Pattern",id:"lens-provider-pattern",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Conditional Lens Operations",id:"conditional-lens-operations",level:3},{value:"Lens Middleware",id:"lens-middleware",level:3},{value:"Testing with Lenses",id:"testing-with-lenses",level:2},{value:"Mock Lens for Testing",id:"mock-lens-for-testing",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Lens as Component Prop",id:"1-use-lens-as-component-prop",level:3},{value:"2. Batch Related Updates",id:"2-batch-related-updates",level:3},{value:"3. Use Appropriate Lens Methods",id:"3-use-appropriate-lens-methods",level:3},{value:"4. Keep Lens Operations Focused",id:"4-keep-lens-operations-focused",level:3},{value:"Related APIs",id:"related-apis",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"uselens",children:"useLens"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useLens"})," hook provides access to the lens system within Refract components. The lens is the primary interface for accessing reactive features like state management, effects, and optics in a component-scoped manner."]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const lens = useLens()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["None. The ",(0,s.jsx)(n.code,{children:"useLens"})," hook takes no parameters."]}),"\n",(0,s.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"Lens"})," object with the following interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Lens {\n  useRefraction<T>(initialValue: T): Refraction<T>;\n  useDerived<T>(compute: () => T, deps: any[]): Refraction<T>;\n  useEffect(effect: () => void | (() => void), deps?: any[]): void;\n  useFlash(effect: () => void, deps?: any[]): void;\n  useOptic<T>(optic: () => T, deps: any[]): T;\n  batch(fn: () => void): void;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.h3,{id:"accessing-the-lens",children:"Accessing the Lens"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { createComponent, useLens } from 'refract';\n\nconst MyComponent = createComponent((props) => {\n  const lens = useLens();\n  \n  // Now you can use all lens methods\n  const state = lens.useRefraction(0);\n  \n  lens.useEffect(() => {\n    console.log('Component mounted');\n  }, []);\n  \n  return <div>Count: {state.value}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"alternative-destructured-props",children:"Alternative: Destructured Props"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Most common pattern - lens is provided as prop\nconst MyComponent = createComponent(({ lens, ...otherProps }) => {\n  const state = lens.useRefraction(0);\n  \n  return <div>Count: {state.value}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lens-methods",children:"Lens Methods"}),"\n",(0,s.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const StateExample = createComponent(({ lens }) => {\n  // Create reactive state\n  const count = lens.useRefraction(0);\n  const user = lens.useRefraction(null);\n  \n  // Create derived state\n  const doubled = lens.useDerived(() => count.value * 2, [count]);\n  \n  return (\n    <div>\n      <p>Count: {count.value}</p>\n      <p>Doubled: {doubled.value}</p>\n      <button onClick={() => count.set(count.value + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"effect-management",children:"Effect Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const EffectExample = createComponent(({ lens, userId }) => {\n  const user = lens.useRefraction(null);\n  \n  // Side effects\n  lens.useEffect(() => {\n    fetchUser(userId).then(user.set);\n  }, [userId]);\n  \n  // Post-render effects\n  lens.useFlash(() => {\n    if (user.value) {\n      document.title = `User: ${user.value.name}`;\n    }\n  }, [user.value]);\n  \n  return <div>{user.value?.name || 'Loading...'}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optic-usage",children:"Optic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const OpticExample = createComponent(({ lens }) => {\n  // Use custom optics\n  const form = lens.useOptic(() => useForm({\n    name: '',\n    email: ''\n  }), []);\n  \n  const api = lens.useOptic(() => useApiClient(), []);\n  \n  return (\n    <form>\n      <input\n        value={form.values.name}\n        onChange={(e) => form.setValue('name', e.target.value)}\n      />\n      <input\n        value={form.values.email}\n        onChange={(e) => form.setValue('email', e.target.value)}\n      />\n    </form>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"batching-updates",children:"Batching Updates"}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const BatchingExample = createComponent(({ lens }) => {\n  const firstName = lens.useRefraction('');\n  const lastName = lens.useRefraction('');\n  const email = lens.useRefraction('');\n  const phone = lens.useRefraction('');\n  \n  const updateAllFields = () => {\n    // Batch multiple updates to prevent multiple re-renders\n    lens.batch(() => {\n      firstName.set('John');\n      lastName.set('Doe');\n      email.set('john.doe@example.com');\n      phone.set('555-1234');\n    });\n  };\n  \n  const updateIndividually = () => {\n    // This would cause 4 separate re-renders\n    firstName.set('Jane');\n    lastName.set('Smith');\n    email.set('jane.smith@example.com');\n    phone.set('555-5678');\n  };\n  \n  return (\n    <div>\n      <p>Name: {firstName.value} {lastName.value}</p>\n      <p>Email: {email.value}</p>\n      <p>Phone: {phone.value}</p>\n      \n      <button onClick={updateAllFields}>\n        Update All (Batched)\n      </button>\n      <button onClick={updateIndividually}>\n        Update All (Individual)\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"complex-batching",children:"Complex Batching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ComplexBatching = createComponent(({ lens }) => {\n  const items = lens.useRefraction([]);\n  const selectedItems = lens.useRefraction(new Set());\n  const totalPrice = lens.useRefraction(0);\n  const discount = lens.useRefraction(0);\n  \n  const addItemsWithCalculation = (newItems) => {\n    lens.batch(() => {\n      // Add items\n      items.set(prev => [...prev, ...newItems]);\n      \n      // Update selections\n      const newSelections = new Set(selectedItems.value);\n      newItems.forEach(item => newSelections.add(item.id));\n      selectedItems.set(newSelections);\n      \n      // Recalculate totals\n      const total = newItems.reduce((sum, item) => sum + item.price, totalPrice.value);\n      totalPrice.set(total);\n      \n      // Apply discount if total is high\n      if (total > 100) {\n        discount.set(10);\n      }\n    });\n  };\n  \n  return (\n    <div>\n      <p>Items: {items.value.length}</p>\n      <p>Selected: {selectedItems.value.size}</p>\n      <p>Total: ${totalPrice.value}</p>\n      <p>Discount: {discount.value}%</p>\n      \n      <button onClick={() => addItemsWithCalculation([\n        { id: 1, name: 'Item 1', price: 50 },\n        { id: 2, name: 'Item 2', price: 75 }\n      ])}>\n        Add Items with Calculation\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lens-composition-patterns",children:"Lens Composition Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"custom-lens-wrapper",children:"Custom Lens Wrapper"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const createEnhancedLens = (baseLens, context) => {\n  return {\n    ...baseLens,\n    \n    // Enhanced useRefraction with validation\n    useValidatedRefraction: (initialValue, validator) => {\n      const refraction = baseLens.useRefraction(initialValue);\n      \n      return {\n        ...refraction,\n        set: (value) => {\n          if (validator && !validator(value)) {\n            console.warn('Invalid value:', value);\n            return;\n          }\n          refraction.set(value);\n        }\n      };\n    },\n    \n    // Context-aware effects\n    useContextualEffect: (effect, deps) => {\n      baseLens.useEffect(() => {\n        return effect(context);\n      }, [context, ...deps]);\n    }\n  };\n};\n\nconst EnhancedComponent = createComponent(({ lens, context }) => {\n  const enhancedLens = createEnhancedLens(lens, context);\n  \n  const validatedCount = enhancedLens.useValidatedRefraction(\n    0, \n    (value) => value >= 0 && value <= 100\n  );\n  \n  return (\n    <div>\n      <p>Count: {validatedCount.value}</p>\n      <button onClick={() => validatedCount.set(validatedCount.value + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lens-provider-pattern",children:"Lens Provider Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const LensProvider = createComponent(({ lens, children, enhancements }) => {\n  const enhancedLens = {\n    ...lens,\n    ...enhancements,\n    \n    // Add debugging capabilities\n    useDebugRefraction: (initialValue, name) => {\n      const refraction = lens.useRefraction(initialValue);\n      \n      lens.useEffect(() => {\n        console.log(`[${name}] changed to:`, refraction.value);\n      }, [refraction.value]);\n      \n      return refraction;\n    }\n  };\n  \n  return children(enhancedLens);\n});\n\nconst ConsumerComponent = createComponent(({ lens }) => {\n  return (\n    <LensProvider enhancements={{ customMethod: () => 'custom' }}>\n      {(enhancedLens) => {\n        const debugCount = enhancedLens.useDebugRefraction(0, 'counter');\n        \n        return (\n          <div>\n            <p>Count: {debugCount.value}</p>\n            <button onClick={() => debugCount.set(debugCount.value + 1)}>\n              Increment (with debug)\n            </button>\n          </div>\n        );\n      }}\n    </LensProvider>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,s.jsx)(n.h3,{id:"conditional-lens-operations",children:"Conditional Lens Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ConditionalLens = createComponent(({ lens, mode }) => {\n  const data = lens.useRefraction(null);\n  \n  // Conditional effects based on mode\n  if (mode === 'live') {\n    lens.useEffect(() => {\n      const interval = setInterval(() => {\n        fetchLiveData().then(data.set);\n      }, 1000);\n      \n      return () => clearInterval(interval);\n    }, []);\n  } else if (mode === 'static') {\n    lens.useEffect(() => {\n      fetchStaticData().then(data.set);\n    }, []);\n  }\n  \n  return <div>{data.value || 'Loading...'}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lens-middleware",children:"Lens Middleware"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const withLensMiddleware = (Component, middleware) => {\n  return createComponent((props) => {\n    const { lens, ...otherProps } = props;\n    \n    const wrappedLens = middleware.reduce((currentLens, middlewareFn) => {\n      return middlewareFn(currentLens);\n    }, lens);\n    \n    return <Component lens={wrappedLens} {...otherProps} />;\n  });\n};\n\n// Logging middleware\nconst loggingMiddleware = (lens) => ({\n  ...lens,\n  useRefraction: (initialValue) => {\n    const refraction = lens.useRefraction(initialValue);\n    console.log('Created refraction with initial value:', initialValue);\n    return refraction;\n  }\n});\n\n// Performance middleware\nconst performanceMiddleware = (lens) => ({\n  ...lens,\n  batch: (fn) => {\n    const start = performance.now();\n    lens.batch(fn);\n    const end = performance.now();\n    console.log(`Batch operation took ${end - start}ms`);\n  }\n});\n\nconst EnhancedComponent = withLensMiddleware(\n  MyComponent,\n  [loggingMiddleware, performanceMiddleware]\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-with-lenses",children:"Testing with Lenses"}),"\n",(0,s.jsx)(n.h3,{id:"mock-lens-for-testing",children:"Mock Lens for Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// test-utils.js\nexport const createMockLens = () => {\n  const refractions = new Map();\n  const effects = [];\n  \n  return {\n    useRefraction: jest.fn((initialValue) => {\n      const id = Symbol();\n      const refraction = {\n        value: initialValue,\n        set: jest.fn((newValue) => {\n          refraction.value = typeof newValue === 'function' \n            ? newValue(refraction.value) \n            : newValue;\n        })\n      };\n      refractions.set(id, refraction);\n      return refraction;\n    }),\n    \n    useEffect: jest.fn((effect, deps) => {\n      effects.push({ effect, deps });\n    }),\n    \n    useFlash: jest.fn(),\n    useOptic: jest.fn(),\n    useDerived: jest.fn(),\n    batch: jest.fn((fn) => fn()),\n    \n    // Test helpers\n    getRefractions: () => Array.from(refractions.values()),\n    getEffects: () => effects\n  };\n};\n\n// Component.test.js\nimport { createMockLens } from './test-utils';\n\ntest('component uses lens correctly', () => {\n  const mockLens = createMockLens();\n  \n  const TestComponent = createComponent(({ lens }) => {\n    const count = lens.useRefraction(0);\n    \n    lens.useEffect(() => {\n      console.log('Effect ran');\n    }, []);\n    \n    return {\n      count,\n      increment: () => count.set(count.value + 1)\n    };\n  });\n  \n  const component = TestComponent({ lens: mockLens });\n  \n  expect(mockLens.useRefraction).toHaveBeenCalledWith(0);\n  expect(mockLens.useEffect).toHaveBeenCalled();\n  \n  component.increment();\n  expect(component.count.set).toHaveBeenCalledWith(1);\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { render, act } from '@refract/testing-utils';\n\ntest('lens integration works correctly', () => {\n  const TestComponent = createComponent(({ lens }) => {\n    const count = lens.useRefraction(0);\n    \n    lens.useEffect(() => {\n      // Simulate async operation\n      setTimeout(() => {\n        count.set(10);\n      }, 100);\n    }, []);\n    \n    return (\n      <div>\n        <span data-testid=\"count\">{count.value}</span>\n        <button onClick={() => count.set(count.value + 1)}>\n          Increment\n        </button>\n      </div>\n    );\n  });\n  \n  const { getByTestId, getByRole } = render(<TestComponent />);\n  \n  expect(getByTestId('count')).toHaveTextContent('0');\n  \n  act(() => {\n    fireEvent.click(getByRole('button'));\n  });\n  \n  expect(getByTestId('count')).toHaveTextContent('1');\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-lens-as-component-prop",children:"1. Use Lens as Component Prop"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Standard pattern\nconst MyComponent = createComponent(({ lens, ...props }) => {\n  const state = lens.useRefraction(0);\n  return <div>{state.value}</div>;\n});\n\n// \u274c Bad - Calling useLens unnecessarily\nconst MyComponent = createComponent((props) => {\n  const lens = useLens(); // Unnecessary when lens is provided as prop\n  const state = lens.useRefraction(0);\n  return <div>{state.value}</div>;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-batch-related-updates",children:"2. Batch Related Updates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Batch related state changes\nconst updateUserProfile = () => {\n  lens.batch(() => {\n    firstName.set('John');\n    lastName.set('Doe');\n    email.set('john.doe@example.com');\n  });\n};\n\n// \u274c Bad - Individual updates cause multiple re-renders\nconst updateUserProfile = () => {\n  firstName.set('John');\n  lastName.set('Doe');\n  email.set('john.doe@example.com');\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-use-appropriate-lens-methods",children:"3. Use Appropriate Lens Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Use the right method for the job\nlens.useEffect(() => {\n  // Side effects with cleanup\n  const subscription = api.subscribe(handleData);\n  return () => subscription.unsubscribe();\n}, []);\n\nlens.useFlash(() => {\n  // DOM manipulation after render\n  elementRef.current?.focus();\n}, [shouldFocus]);\n\n// \u274c Bad - Using wrong method\nlens.useFlash(() => {\n  // Side effects should use useEffect, not useFlash\n  const subscription = api.subscribe(handleData);\n}, []);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-keep-lens-operations-focused",children:"4. Keep Lens Operations Focused"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Focused, single-purpose operations\nconst UserProfile = createComponent(({ lens, userId }) => {\n  const user = lens.useRefraction(null);\n  const loading = lens.useRefraction(false);\n  \n  lens.useEffect(() => {\n    loading.set(true);\n    fetchUser(userId).then(user.set).finally(() => loading.set(false));\n  }, [userId]);\n  \n  return <div>{loading.value ? 'Loading...' : user.value?.name}</div>;\n});\n\n// \u274c Bad - Mixed concerns in single operations\nconst UserProfile = createComponent(({ lens, userId }) => {\n  const everything = lens.useRefraction({\n    user: null,\n    loading: false,\n    posts: [],\n    settings: {},\n    // ... too much in one state\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-apis",children:"Related APIs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./createComponent",children:"createComponent"})})," - Components that receive lens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useRefraction",children:"useRefraction"})})," - State management through lens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useEffect",children:"useEffect"})})," - Side effects through lens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useOptic",children:"useOptic"})})," - Reusable logic through lens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useFlash",children:"useFlash"})})," - Post-render effects through lens"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);