"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[5305],{6145:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api/useEffect","title":"useEffect","description":"The useEffect hook handles side effects and lifecycle management in Refract components. It provides a declarative way to perform operations like data fetching, subscriptions, timers, and DOM manipulation while ensuring proper cleanup and dependency tracking.","source":"@site/docs/api/useEffect.md","sourceDirName":"api","slug":"/api/useEffect","permalink":"/docs/api/useEffect","draft":false,"unlisted":false,"editUrl":"https://github.com/refract-js/refract/tree/main/docs/docs/api/useEffect.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"useRefraction","permalink":"/docs/api/useRefraction"},"next":{"title":"useFlash","permalink":"/docs/api/useFlash"}}');var r=t(4848),c=t(8453);const a={},i="useEffect",o={},l=[{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"<code>effect</code>",id:"effect",level:3},{value:"<code>dependencies</code>",id:"dependencies",level:3},{value:"Return Value",id:"return-value",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Mount Effect",id:"mount-effect",level:3},{value:"Dependency-Based Effects",id:"dependency-based-effects",level:3},{value:"State-Dependent Effects",id:"state-dependent-effects",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Async Effects",id:"async-effects",level:3},{value:"Event Listeners",id:"event-listeners",level:3},{value:"Subscriptions and WebSockets",id:"subscriptions-and-websockets",level:3},{value:"Timers and Intervals",id:"timers-and-intervals",level:3},{value:"Effect Dependencies",id:"effect-dependencies",level:2},{value:"Dependency Array Rules",id:"dependency-array-rules",level:3},{value:"Memoizing Dependencies",id:"memoizing-dependencies",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Try-Catch in Effects",id:"try-catch-in-effects",level:3},{value:"Effect Error Boundaries",id:"effect-error-boundaries",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Conditional Effects",id:"conditional-effects",level:3},{value:"Debounced Effects",id:"debounced-effects",level:3},{value:"Testing Effects",id:"testing-effects",level:2},{value:"Mocking Effects",id:"mocking-effects",level:3},{value:"Testing Cleanup",id:"testing-cleanup",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Handle Cleanup",id:"1-always-handle-cleanup",level:3},{value:"2. Use Specific Dependencies",id:"2-use-specific-dependencies",level:3},{value:"3. Handle Async Operations Safely",id:"3-handle-async-operations-safely",level:3},{value:"4. Separate Concerns",id:"4-separate-concerns",level:3},{value:"Related APIs",id:"related-apis",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"useeffect",children:"useEffect"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useEffect"})," hook handles side effects and lifecycle management in Refract components. It provides a declarative way to perform operations like data fetching, subscriptions, timers, and DOM manipulation while ensuring proper cleanup and dependency tracking."]}),"\n",(0,r.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"lens.useEffect(effect, dependencies?)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsx)(n.h3,{id:"effect",children:(0,r.jsx)(n.code,{children:"effect"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"() => void | (() => void)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Required:"})," Yes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," Function that contains side effect logic. Can optionally return a cleanup function."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dependencies",children:(0,r.jsx)(n.code,{children:"dependencies"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type:"})," ",(0,r.jsx)(n.code,{children:"any[] | undefined"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Required:"})," No"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Description:"})," Array of values that the effect depends on. Effect re-runs when dependencies change."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,r.jsxs)(n.p,{children:["Returns ",(0,r.jsx)(n.code,{children:"void"}),". The effect function can optionally return a cleanup function."]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.h3,{id:"mount-effect",children:"Mount Effect"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const MountExample = createComponent(({ lens }) => {\n  const data = lens.useRefraction(null);\n  \n  // Runs once when component mounts\n  lens.useEffect(() => {\n    console.log('Component mounted');\n    \n    fetchInitialData().then(data.set);\n    \n    // Optional cleanup on unmount\n    return () => {\n      console.log('Component unmounting');\n    };\n  }, []); // Empty dependency array = mount only\n  \n  return <div>{data.value || 'Loading...'}</div>;\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dependency-based-effects",children:"Dependency-Based Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const DependencyExample = createComponent(({ lens, userId }) => {\n  const user = lens.useRefraction(null);\n  const loading = lens.useRefraction(false);\n  \n  // Runs when userId changes\n  lens.useEffect(() => {\n    if (!userId) return;\n    \n    loading.set(true);\n    \n    fetchUser(userId)\n      .then(user.set)\n      .finally(() => loading.set(false));\n  }, [userId]); // Runs when userId prop changes\n  \n  return (\n    <div>\n      {loading.value ? 'Loading...' : user.value?.name}\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"state-dependent-effects",children:"State-Dependent Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const StateEffect = createComponent(({ lens }) => {\n  const searchQuery = lens.useRefraction('');\n  const results = lens.useRefraction([]);\n  \n  // Runs when searchQuery changes\n  lens.useEffect(() => {\n    if (searchQuery.value.length < 3) {\n      results.set([]);\n      return;\n    }\n    \n    const searchTimeout = setTimeout(() => {\n      performSearch(searchQuery.value).then(results.set);\n    }, 300);\n    \n    // Cleanup timeout on next effect run\n    return () => clearTimeout(searchTimeout);\n  }, [searchQuery.value]);\n  \n  return (\n    <div>\n      <input\n        value={searchQuery.value}\n        onChange={(e) => searchQuery.set(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.value.map(result => (\n          <li key={result.id}>{result.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"async-effects",children:"Async Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const AsyncEffect = createComponent(({ lens, productId }) => {\n  const product = lens.useRefraction(null);\n  const loading = lens.useRefraction(false);\n  const error = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    let cancelled = false;\n    \n    const loadProduct = async () => {\n      loading.set(true);\n      error.set(null);\n      \n      try {\n        const response = await fetch(`/api/products/${productId}`);\n        \n        if (!response.ok) {\n          throw new Error(`Failed to fetch product: ${response.status}`);\n        }\n        \n        const productData = await response.json();\n        \n        // Only update state if effect hasn't been cancelled\n        if (!cancelled) {\n          product.set(productData);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          error.set(err.message);\n        }\n      } finally {\n        if (!cancelled) {\n          loading.set(false);\n        }\n      }\n    };\n    \n    loadProduct();\n    \n    // Cleanup: cancel the async operation\n    return () => {\n      cancelled = true;\n    };\n  }, [productId]);\n  \n  if (loading.value) return <div>Loading product...</div>;\n  if (error.value) return <div>Error: {error.value}</div>;\n  if (!product.value) return <div>Product not found</div>;\n  \n  return (\n    <div>\n      <h2>{product.value.name}</h2>\n      <p>{product.value.description}</p>\n      <p>Price: ${product.value.price}</p>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-listeners",children:"Event Listeners"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const EventListenerEffect = createComponent(({ lens }) => {\n  const windowSize = lens.useRefraction({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n  \n  const mousePosition = lens.useRefraction({ x: 0, y: 0 });\n  const isTracking = lens.useRefraction(false);\n  \n  // Window resize listener\n  lens.useEffect(() => {\n    const handleResize = () => {\n      windowSize.set({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  \n  // Mouse tracking (conditional)\n  lens.useEffect(() => {\n    if (!isTracking.value) return;\n    \n    const handleMouseMove = (event) => {\n      mousePosition.set({\n        x: event.clientX,\n        y: event.clientY\n      });\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    \n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [isTracking.value]);\n  \n  return (\n    <div>\n      <p>Window: {windowSize.value.width} x {windowSize.value.height}</p>\n      <button onClick={() => isTracking.set(!isTracking.value)}>\n        {isTracking.value ? 'Stop' : 'Start'} Mouse Tracking\n      </button>\n      {isTracking.value && (\n        <p>Mouse: ({mousePosition.value.x}, {mousePosition.value.y})</p>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"subscriptions-and-websockets",children:"Subscriptions and WebSockets"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const WebSocketEffect = createComponent(({ lens, roomId }) => {\n  const messages = lens.useRefraction([]);\n  const connectionStatus = lens.useRefraction('disconnected');\n  \n  lens.useEffect(() => {\n    if (!roomId) return;\n    \n    connectionStatus.set('connecting');\n    \n    const ws = new WebSocket(`ws://localhost:8080/rooms/${roomId}`);\n    \n    ws.onopen = () => {\n      connectionStatus.set('connected');\n    };\n    \n    ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      messages.set(prev => [...prev, message]);\n    };\n    \n    ws.onclose = () => {\n      connectionStatus.set('disconnected');\n    };\n    \n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      connectionStatus.set('error');\n    };\n    \n    // Cleanup: close WebSocket connection\n    return () => {\n      ws.close();\n    };\n  }, [roomId]);\n  \n  const sendMessage = (text) => {\n    // Implementation would depend on WebSocket state\n    console.log('Sending message:', text);\n  };\n  \n  return (\n    <div>\n      <div>Status: {connectionStatus.value}</div>\n      <div>\n        {messages.value.map(msg => (\n          <div key={msg.id}>{msg.user}: {msg.text}</div>\n        ))}\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"timers-and-intervals",children:"Timers and Intervals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const TimerEffect = createComponent(({ lens }) => {\n  const time = lens.useRefraction(new Date());\n  const isRunning = lens.useRefraction(false);\n  const countdown = lens.useRefraction(60);\n  \n  // Clock timer\n  lens.useEffect(() => {\n    if (!isRunning.value) return;\n    \n    const interval = setInterval(() => {\n      time.set(new Date());\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, [isRunning.value]);\n  \n  // Countdown timer\n  lens.useEffect(() => {\n    if (countdown.value <= 0) return;\n    \n    const timer = setTimeout(() => {\n      countdown.set(prev => prev - 1);\n    }, 1000);\n    \n    return () => clearTimeout(timer);\n  }, [countdown.value]);\n  \n  return (\n    <div>\n      <div>\n        <h3>Clock</h3>\n        <p>{time.value.toLocaleTimeString()}</p>\n        <button onClick={() => isRunning.set(!isRunning.value)}>\n          {isRunning.value ? 'Stop' : 'Start'} Clock\n        </button>\n      </div>\n      \n      <div>\n        <h3>Countdown</h3>\n        <p>{countdown.value} seconds</p>\n        <button onClick={() => countdown.set(60)}>\n          Reset Countdown\n        </button>\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"effect-dependencies",children:"Effect Dependencies"}),"\n",(0,r.jsx)(n.h3,{id:"dependency-array-rules",children:"Dependency Array Rules"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const DependencyRules = createComponent(({ lens, userId, config }) => {\n  const data = lens.useRefraction(null);\n  \n  // \u2705 Good - Specific dependencies\n  lens.useEffect(() => {\n    fetchUserData(userId, config.apiKey).then(data.set);\n  }, [userId, config.apiKey]);\n  \n  // \u274c Bad - Missing dependencies\n  lens.useEffect(() => {\n    fetchUserData(userId, config.apiKey).then(data.set);\n  }, [userId]); // Missing config.apiKey\n  \n  // \u274c Bad - Unnecessary dependencies\n  lens.useEffect(() => {\n    fetchUserData(userId).then(data.set);\n  }, [userId, config]); // config not used in effect\n  \n  return <div>{data.value?.name}</div>;\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"memoizing-dependencies",children:"Memoizing Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const MemoizedDependencies = createComponent(({ lens, items }) => {\n  const processedItems = lens.useRefraction([]);\n  \n  // Memoize expensive computation for dependency\n  const itemIds = lens.useDerived(() => \n    items.map(item => item.id).join(','), \n    [items]\n  );\n  \n  lens.useEffect(() => {\n    // Only runs when item IDs change, not when other item properties change\n    const processed = items.map(processItem);\n    processedItems.set(processed);\n  }, [itemIds.value]);\n  \n  return (\n    <ul>\n      {processedItems.value.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.h3,{id:"try-catch-in-effects",children:"Try-Catch in Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const ErrorHandlingEffect = createComponent(({ lens }) => {\n  const data = lens.useRefraction(null);\n  const error = lens.useRefraction(null);\n  const loading = lens.useRefraction(false);\n  \n  lens.useEffect(() => {\n    const loadData = async () => {\n      try {\n        loading.set(true);\n        error.set(null);\n        \n        const result = await riskyAsyncOperation();\n        data.set(result);\n      } catch (err) {\n        console.error('Effect error:', err);\n        error.set(err.message);\n      } finally {\n        loading.set(false);\n      }\n    };\n    \n    loadData();\n  }, []);\n  \n  if (loading.value) return <div>Loading...</div>;\n  if (error.value) return <div>Error: {error.value}</div>;\n  \n  return <div>{JSON.stringify(data.value)}</div>;\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"effect-error-boundaries",children:"Effect Error Boundaries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const withEffectErrorHandling = (Component) => {\n  return createComponent((props) => {\n    const { lens } = props;\n    const hasEffectError = lens.useRefraction(false);\n    const effectError = lens.useRefraction(null);\n    \n    // Wrap effects with error handling\n    const safeUseEffect = (effect, deps) => {\n      lens.useEffect(() => {\n        try {\n          const cleanup = effect();\n          return cleanup;\n        } catch (error) {\n          hasEffectError.set(true);\n          effectError.set(error);\n        }\n      }, deps);\n    };\n    \n    if (hasEffectError.value) {\n      return (\n        <div className="effect-error">\n          <h3>Effect Error</h3>\n          <p>{effectError.value?.message}</p>\n          <button onClick={() => hasEffectError.set(false)}>\n            Retry\n          </button>\n        </div>\n      );\n    }\n    \n    return <Component {...props} useEffect={safeUseEffect} />;\n  });\n};\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"conditional-effects",children:"Conditional Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const ConditionalEffect = createComponent(({ lens, isEnabled, shouldFetch }) => {\n  const data = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    // Only run effect when conditions are met\n    if (!isEnabled || !shouldFetch) return;\n    \n    fetchData().then(data.set);\n  }, [isEnabled, shouldFetch]);\n  \n  return <div>{data.value || 'No data'}</div>;\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"debounced-effects",children:"Debounced Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const DebouncedEffect = createComponent(({ lens }) => {\n  const searchTerm = lens.useRefraction('');\n  const results = lens.useRefraction([]);\n  \n  lens.useEffect(() => {\n    if (!searchTerm.value) {\n      results.set([]);\n      return;\n    }\n    \n    // Debounce the search\n    const timeoutId = setTimeout(() => {\n      performSearch(searchTerm.value).then(results.set);\n    }, 300);\n    \n    return () => clearTimeout(timeoutId);\n  }, [searchTerm.value]);\n  \n  return (\n    <div>\n      <input\n        value={searchTerm.value}\n        onChange={(e) => searchTerm.set(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <ul>\n        {results.value.map(result => (\n          <li key={result.id}>{result.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-effects",children:"Testing Effects"}),"\n",(0,r.jsx)(n.h3,{id:"mocking-effects",children:"Mocking Effects"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { render, waitFor } from '@refract/testing-utils';\n\n// Mock fetch for testing\nglobal.fetch = jest.fn();\n\ndescribe('AsyncEffect Component', () => {\n  beforeEach(() => {\n    fetch.mockClear();\n  });\n  \n  test('fetches data on mount', async () => {\n    const mockData = { id: 1, name: 'Test Product' };\n    fetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () => mockData\n    });\n    \n    const { getByText } = render(<AsyncEffect productId={1} />);\n    \n    // Initially shows loading\n    expect(getByText('Loading product...')).toBeInTheDocument();\n    \n    // Wait for data to load\n    await waitFor(() => {\n      expect(getByText('Test Product')).toBeInTheDocument();\n    });\n    \n    expect(fetch).toHaveBeenCalledWith('/api/products/1');\n  });\n  \n  test('handles fetch errors', async () => {\n    fetch.mockRejectedValueOnce(new Error('Network error'));\n    \n    const { getByText } = render(<AsyncEffect productId={1} />);\n    \n    await waitFor(() => {\n      expect(getByText('Error: Network error')).toBeInTheDocument();\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"testing-cleanup",children:"Testing Cleanup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"test('cleans up event listeners on unmount', () => {\n  const addEventListenerSpy = jest.spyOn(window, 'addEventListener');\n  const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');\n  \n  const { unmount } = render(<EventListenerEffect />);\n  \n  expect(addEventListenerSpy).toHaveBeenCalledWith('resize', expect.any(Function));\n  \n  unmount();\n  \n  expect(removeEventListenerSpy).toHaveBeenCalledWith('resize', expect.any(Function));\n  \n  addEventListenerSpy.mockRestore();\n  removeEventListenerSpy.mockRestore();\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-always-handle-cleanup",children:"1. Always Handle Cleanup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  const subscription = api.subscribe(handleData);\n  return () => subscription.unsubscribe();\n}, []);\n\n// \u274c Bad - No cleanup\nlens.useEffect(() => {\n  api.subscribe(handleData);\n}, []);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-use-specific-dependencies",children:"2. Use Specific Dependencies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  fetchUser(userId);\n}, [userId]);\n\n// \u274c Bad - Missing dependencies\nlens.useEffect(() => {\n  fetchUser(userId);\n}, []);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-handle-async-operations-safely",children:"3. Handle Async Operations Safely"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  let cancelled = false;\n  \n  fetchData().then(data => {\n    if (!cancelled) {\n      setData(data);\n    }\n  });\n  \n  return () => {\n    cancelled = true;\n  };\n}, []);\n\n// \u274c Bad - Race conditions possible\nlens.useEffect(() => {\n  fetchData().then(setData);\n}, []);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-separate-concerns",children:"4. Separate Concerns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Separate effects for different concerns\nlens.useEffect(() => {\n  fetchUserData(userId).then(setUser);\n}, [userId]);\n\nlens.useEffect(() => {\n  trackPageView(pageName);\n}, [pageName]);\n\n// \u274c Bad - Mixed concerns\nlens.useEffect(() => {\n  fetchUserData(userId).then(setUser);\n  trackPageView(pageName);\n}, [userId, pageName]);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-apis",children:"Related APIs"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./useFlash",children:"useFlash"})})," - Post-render effects for animations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./useOptic",children:"useOptic"})})," - Reusable logic patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./useRefraction",children:"useRefraction"})})," - State that effects can respond to"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./createComponent",children:"createComponent"})})," - Components that use effects"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const r={},c=s.createContext(r);function a(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);