"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[6240],{1680:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"concepts/lenses","title":"Lenses","description":"Lenses are Refract\'s scoped interface to reactive features within components. They provide a clean, organized way to access refractions, effects, and optics while maintaining proper component boundaries and lifecycle management.","source":"@site/docs/concepts/lenses.md","sourceDirName":"concepts","slug":"/concepts/lenses","permalink":"/docs/concepts/lenses","draft":false,"unlisted":false,"editUrl":"https://github.com/refract-js/refract/tree/main/docs/docs/concepts/lenses.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Refractions","permalink":"/docs/concepts/refractions"},"next":{"title":"Optics","permalink":"/docs/concepts/optics"}}');var a=t(4848),o=t(8453);const r={},i="Lenses",c={},l=[{value:"What are Lenses?",id:"what-are-lenses",level:2},{value:"Lens API Overview",id:"lens-api-overview",level:2},{value:"Core Methods",id:"core-methods",level:3},{value:"Scoped State Management",id:"scoped-state-management",level:2},{value:"Local Component State",id:"local-component-state",level:3},{value:"State Isolation",id:"state-isolation",level:3},{value:"Effect Management",id:"effect-management",level:2},{value:"Component Lifecycle",id:"component-lifecycle",level:3},{value:"Event Listeners and Subscriptions",id:"event-listeners-and-subscriptions",level:3},{value:"Optic Integration",id:"optic-integration",level:2},{value:"Custom Hooks with Lenses",id:"custom-hooks-with-lenses",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Batching Updates",id:"batching-updates",level:3},{value:"Conditional Effects",id:"conditional-effects",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Lens Composition",id:"lens-composition",level:3},{value:"Lens Providers",id:"lens-providers",level:3},{value:"Testing with Lenses",id:"testing-with-lenses",level:2},{value:"Mock Lenses for Testing",id:"mock-lenses-for-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Descriptive Lens Operations",id:"1-use-descriptive-lens-operations",level:3},{value:"2. Organize Effects Logically",id:"2-organize-effects-logically",level:3},{value:"3. Handle Cleanup Properly",id:"3-handle-cleanup-properly",level:3},{value:"4. Use Batch for Multiple Updates",id:"4-use-batch-for-multiple-updates",level:3},{value:"Debugging Lenses",id:"debugging-lenses",level:2},{value:"Lens Inspector",id:"lens-inspector",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"lenses",children:"Lenses"})}),"\n",(0,a.jsx)(n.p,{children:"Lenses are Refract's scoped interface to reactive features within components. They provide a clean, organized way to access refractions, effects, and optics while maintaining proper component boundaries and lifecycle management."}),"\n",(0,a.jsx)(n.h2,{id:"what-are-lenses",children:"What are Lenses?"}),"\n",(0,a.jsxs)(n.p,{children:["A lens is a component-scoped object that provides access to Refract's reactive system. Every component created with ",(0,a.jsx)(n.code,{children:"createComponent()"})," receives a lens as its first parameter, giving you access to:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Refractions"})," - Reactive state management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Effects"})," - Side effect handling and lifecycle"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optics"})," - Reusable logic patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batching"})," - Performance optimization"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { createComponent } from 'refract';\n\nconst MyComponent = createComponent(({ lens, ...props }) => {\n  // lens provides scoped access to reactive features\n  const state = lens.useRefraction(0);\n  \n  lens.useEffect(() => {\n    console.log('Component mounted');\n  }, []);\n  \n  return <div>Count: {state.value}</div>;\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"lens-api-overview",children:"Lens API Overview"}),"\n",(0,a.jsx)(n.h3,{id:"core-methods",children:"Core Methods"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ExampleComponent = createComponent(({ lens }) => {\n  // State management\n  const count = lens.useRefraction(0);\n  const user = lens.useRefraction(null);\n  \n  // Derived state\n  const doubled = lens.useDerived(() => count.value * 2, [count]);\n  \n  // Side effects\n  lens.useEffect(() => {\n    // Effect logic\n  }, []);\n  \n  // Reusable logic\n  const customLogic = lens.useOptic(() => {\n    // Custom optic logic\n  }, []);\n  \n  // Performance optimization\n  lens.batch(() => {\n    count.set(5);\n    user.set({ name: 'John' });\n  });\n  \n  return <div>Component content</div>;\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"scoped-state-management",children:"Scoped State Management"}),"\n",(0,a.jsx)(n.h3,{id:"local-component-state",children:"Local Component State"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const UserProfile = createComponent(({ lens, userId }) => {\n  // Each component instance has its own scoped state\n  const profile = lens.useRefraction(null);\n  const loading = lens.useRefraction(true);\n  const error = lens.useRefraction(null);\n  \n  const fetchProfile = async () => {\n    loading.set(true);\n    error.set(null);\n    \n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      const data = await response.json();\n      profile.set(data);\n    } catch (err) {\n      error.set(err.message);\n    } finally {\n      loading.set(false);\n    }\n  };\n  \n  lens.useEffect(() => {\n    fetchProfile();\n  }, [userId]);\n  \n  if (loading.value) return <div>Loading profile...</div>;\n  if (error.value) return <div>Error: {error.value}</div>;\n  \n  return (\n    <div className="user-profile">\n      <h2>{profile.value?.name}</h2>\n      <p>{profile.value?.email}</p>\n      <button onClick={fetchProfile}>Refresh</button>\n    </div>\n  );\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"state-isolation",children:"State Isolation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const CounterList = createComponent(({ lens }) => {\n  const counters = lens.useRefraction([\n    { id: 1, name: 'Counter A' },\n    { id: 2, name: 'Counter B' },\n    { id: 3, name: 'Counter C' }\n  ]);\n  \n  return (\n    <div>\n      <h2>Multiple Counters</h2>\n      {counters.value.map(counter => (\n        <Counter key={counter.id} name={counter.name} />\n      ))}\n    </div>\n  );\n});\n\nconst Counter = createComponent(({ lens, name }) => {\n  // Each Counter has its own isolated state\n  const count = lens.useRefraction(0);\n  \n  return (\n    <div className=\"counter\">\n      <h3>{name}</h3>\n      <p>Count: {count.value}</p>\n      <button onClick={() => count.set(count.value + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"effect-management",children:"Effect Management"}),"\n",(0,a.jsx)(n.h3,{id:"component-lifecycle",children:"Component Lifecycle"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const LifecycleExample = createComponent(({ lens, data }) => {\n  const processedData = lens.useRefraction(null);\n  \n  // Mount effect\n  lens.useEffect(() => {\n    console.log('Component mounted');\n    \n    // Cleanup on unmount\n    return () => {\n      console.log('Component unmounting');\n    };\n  }, []);\n  \n  // Update effect\n  lens.useEffect(() => {\n    console.log('Data changed:', data);\n    \n    // Process data when it changes\n    const processed = processData(data);\n    processedData.set(processed);\n  }, [data]);\n  \n  return (\n    <div>\n      {processedData.value ? (\n        <DataDisplay data={processedData.value} />\n      ) : (\n        <div>Processing data...</div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"event-listeners-and-subscriptions",children:"Event Listeners and Subscriptions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const WindowSizeTracker = createComponent(({ lens }) => {\n  const windowSize = lens.useRefraction({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n  \n  lens.useEffect(() => {\n    const handleResize = () => {\n      windowSize.set({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Cleanup listener\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  \n  return (\n    <div>\n      <p>Window size: {windowSize.value.width} x {windowSize.value.height}</p>\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"optic-integration",children:"Optic Integration"}),"\n",(0,a.jsx)(n.h3,{id:"custom-hooks-with-lenses",children:"Custom Hooks with Lenses"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Custom optic for form handling\nconst useForm = (initialValues) => {\n  const values = useRefraction(initialValues);\n  const errors = useRefraction({});\n  const touched = useRefraction({});\n  \n  const setValue = (field, value) => {\n    values.update(field, value);\n    \n    // Clear error when user starts typing\n    if (errors.value[field]) {\n      errors.update(field, null);\n    }\n  };\n  \n  const setError = (field, error) => {\n    errors.update(field, error);\n  };\n  \n  const setTouched = (field) => {\n    touched.update(field, true);\n  };\n  \n  const validate = (validationRules) => {\n    const newErrors = {};\n    \n    Object.keys(validationRules).forEach(field => {\n      const rule = validationRules[field];\n      const value = values.value[field];\n      \n      if (rule.required && !value) {\n        newErrors[field] = `${field} is required`;\n      } else if (rule.minLength && value.length < rule.minLength) {\n        newErrors[field] = `${field} must be at least ${rule.minLength} characters`;\n      }\n    });\n    \n    errors.set(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n  \n  return {\n    values: values.value,\n    errors: errors.value,\n    touched: touched.value,\n    setValue,\n    setError,\n    setTouched,\n    validate\n  };\n};\n\n// Using the custom optic\nconst ContactForm = createComponent(({ lens }) => {\n  const form = lens.useOptic(() => useForm({\n    name: '',\n    email: '',\n    message: ''\n  }), []);\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    \n    const isValid = form.validate({\n      name: { required: true, minLength: 2 },\n      email: { required: true },\n      message: { required: true, minLength: 10 }\n    });\n    \n    if (isValid) {\n      console.log('Form submitted:', form.values);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <input\n          value={form.values.name}\n          onChange={(e) => form.setValue('name', e.target.value)}\n          onBlur={() => form.setTouched('name')}\n          placeholder=\"Name\"\n        />\n        {form.touched.name && form.errors.name && (\n          <span className=\"error\">{form.errors.name}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          type=\"email\"\n          value={form.values.email}\n          onChange={(e) => form.setValue('email', e.target.value)}\n          onBlur={() => form.setTouched('email')}\n          placeholder=\"Email\"\n        />\n        {form.touched.email && form.errors.email && (\n          <span className=\"error\">{form.errors.email}</span>\n        )}\n      </div>\n      \n      <div>\n        <textarea\n          value={form.values.message}\n          onChange={(e) => form.setValue('message', e.target.value)}\n          onBlur={() => form.setTouched('message')}\n          placeholder=\"Message\"\n        />\n        {form.touched.message && form.errors.message && (\n          <span className=\"error\">{form.errors.message}</span>\n        )}\n      </div>\n      \n      <button type=\"submit\">Send Message</button>\n    </form>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"batching-updates",children:"Batching Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const BatchingExample = createComponent(({ lens }) => {\n  const firstName = lens.useRefraction('');\n  const lastName = lens.useRefraction('');\n  const email = lens.useRefraction('');\n  const phone = lens.useRefraction('');\n  \n  const updateAllFields = () => {\n    // Without batching: 4 separate re-renders\n    // firstName.set('John');\n    // lastName.set('Doe');\n    // email.set('john.doe@example.com');\n    // phone.set('555-1234');\n    \n    // With batching: 1 re-render for all updates\n    lens.batch(() => {\n      firstName.set('John');\n      lastName.set('Doe');\n      email.set('john.doe@example.com');\n      phone.set('555-1234');\n    });\n  };\n  \n  return (\n    <div>\n      <p>Name: {firstName.value} {lastName.value}</p>\n      <p>Email: {email.value}</p>\n      <p>Phone: {phone.value}</p>\n      <button onClick={updateAllFields}>\n        Update All Fields\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"conditional-effects",children:"Conditional Effects"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ConditionalEffects = createComponent(({ lens, isActive }) => {\n  const data = lens.useRefraction(null);\n  \n  // Effect only runs when component is active\n  lens.useEffect(() => {\n    if (!isActive) return;\n    \n    const interval = setInterval(() => {\n      fetchLatestData().then(data.set);\n    }, 5000);\n    \n    return () => clearInterval(interval);\n  }, [isActive]);\n  \n  return (\n    <div>\n      {isActive ? (\n        <div>Active: {data.value || 'Loading...'}</div>\n      ) : (\n        <div>Inactive</div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"lens-composition",children:"Lens Composition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const useLensComposition = (lens) => {\n  // Create sub-lenses for different concerns\n  const stateLens = {\n    useRefraction: lens.useRefraction,\n    useDerived: lens.useDerived,\n    batch: lens.batch\n  };\n  \n  const effectLens = {\n    useEffect: lens.useEffect,\n    useOptic: lens.useOptic\n  };\n  \n  return { stateLens, effectLens };\n};\n\nconst ComposedComponent = createComponent(({ lens }) => {\n  const { stateLens, effectLens } = useLensComposition(lens);\n  \n  const count = stateLens.useRefraction(0);\n  \n  effectLens.useEffect(() => {\n    console.log('Count changed:', count.value);\n  }, [count.value]);\n  \n  return <div>Count: {count.value}</div>;\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"lens-providers",children:"Lens Providers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const LensProvider = createComponent(({ lens, children, context }) => {\n  // Enhance lens with additional context\n  const enhancedLens = {\n    ...lens,\n    context,\n    useContextualRefraction: (key, defaultValue) => {\n      return lens.useRefraction(context[key] || defaultValue);\n    }\n  };\n  \n  return children(enhancedLens);\n});\n\nconst ContextualComponent = createComponent(({ lens }) => {\n  return (\n    <LensProvider context={{ theme: 'dark', user: { id: 1 } }}>\n      {(enhancedLens) => {\n        const theme = enhancedLens.useContextualRefraction('theme', 'light');\n        \n        return (\n          <div className={`theme-${theme.value}`}>\n            Themed content\n          </div>\n        );\n      }}\n    </LensProvider>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing-with-lenses",children:"Testing with Lenses"}),"\n",(0,a.jsx)(n.h3,{id:"mock-lenses-for-testing",children:"Mock Lenses for Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// test-utils.js\nexport const createMockLens = () => {\n  const refractions = new Map();\n  \n  return {\n    useRefraction: (initialValue) => {\n      const id = Symbol();\n      const refraction = {\n        value: initialValue,\n        set: (newValue) => {\n          refraction.value = typeof newValue === 'function' \n            ? newValue(refraction.value) \n            : newValue;\n        }\n      };\n      refractions.set(id, refraction);\n      return refraction;\n    },\n    \n    useEffect: jest.fn(),\n    useOptic: jest.fn(),\n    batch: (fn) => fn(),\n    \n    // Test helpers\n    getRefractions: () => Array.from(refractions.values())\n  };\n};\n\n// Component.test.js\nimport { createMockLens } from './test-utils';\n\ntest('Counter component increments correctly', () => {\n  const mockLens = createMockLens();\n  \n  const Counter = createComponent(({ lens }) => {\n    const count = lens.useRefraction(0);\n    \n    return {\n      count,\n      increment: () => count.set(count.value + 1)\n    };\n  });\n  \n  const component = Counter({ lens: mockLens });\n  \n  expect(component.count.value).toBe(0);\n  \n  component.increment();\n  expect(component.count.value).toBe(1);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-use-descriptive-lens-operations",children:"1. Use Descriptive Lens Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nconst UserDashboard = createComponent(({ lens, userId }) => {\n  const userProfile = lens.useRefraction(null);\n  const userPosts = lens.useRefraction([]);\n  \n  lens.useEffect(() => {\n    loadUserProfile(userId).then(userProfile.set);\n  }, [userId]);\n});\n\n// \u274c Bad\nconst UserDashboard = createComponent(({ lens, userId }) => {\n  const data1 = lens.useRefraction(null);\n  const data2 = lens.useRefraction([]);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-organize-effects-logically",children:"2. Organize Effects Logically"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Group related effects\nconst DataComponent = createComponent(({ lens }) => {\n  const data = lens.useRefraction(null);\n  \n  // Data fetching effect\n  lens.useEffect(() => {\n    fetchData().then(data.set);\n  }, []);\n  \n  // Data validation effect\n  lens.useEffect(() => {\n    if (data.value) {\n      validateData(data.value);\n    }\n  }, [data.value]);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-handle-cleanup-properly",children:"3. Handle Cleanup Properly"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Always cleanup subscriptions\nconst SubscriptionComponent = createComponent(({ lens }) => {\n  const messages = lens.useRefraction([]);\n  \n  lens.useEffect(() => {\n    const subscription = messageService.subscribe((message) => {\n      messages.set(prev => [...prev, message]);\n    });\n    \n    // Always return cleanup function\n    return () => subscription.unsubscribe();\n  }, []);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-use-batch-for-multiple-updates",children:"4. Use Batch for Multiple Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Batch related updates\nconst FormComponent = createComponent(({ lens }) => {\n  const form = lens.useRefraction({ name: '', email: '' });\n  const errors = lens.useRefraction({});\n  \n  const resetForm = () => {\n    lens.batch(() => {\n      form.set({ name: '', email: '' });\n      errors.set({});\n    });\n  };\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-lenses",children:"Debugging Lenses"}),"\n",(0,a.jsx)(n.h3,{id:"lens-inspector",children:"Lens Inspector"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const LensInspector = createComponent(({ lens, name }) => {\n  const operations = lens.useRefraction([]);\n  \n  // Wrap lens methods to track operations\n  const trackedLens = {\n    ...lens,\n    useRefraction: (...args) => {\n      operations.set(prev => [...prev, {\n        type: 'useRefraction',\n        args,\n        timestamp: Date.now()\n      }]);\n      return lens.useRefraction(...args);\n    },\n    useEffect: (...args) => {\n      operations.set(prev => [...prev, {\n        type: 'useEffect',\n        timestamp: Date.now()\n      }]);\n      return lens.useEffect(...args);\n    }\n  };\n  \n  return (\n    <div className=\"lens-inspector\">\n      <h4>Lens Operations for {name}</h4>\n      <ul>\n        {operations.value.map((op, index) => (\n          <li key={index}>\n            {op.type} at {new Date(op.timestamp).toLocaleTimeString()}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Now that you understand lenses, explore:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./optics",children:"Optics"})})," - Reusable logic patterns"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"./effects",children:"Effects"})})," - Advanced side effect management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../api/overview",children:"API Reference"})})," - Complete API documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);