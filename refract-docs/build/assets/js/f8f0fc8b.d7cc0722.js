"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[536],{3222:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=t(4848),l=t(8453);const a={},i="useFlash",r={id:"api/useFlash",title:"useFlash",description:"The useFlash hook executes effects after the component has rendered and the DOM has been updated. It's specifically designed for operations that need to happen after the render cycle, such as animations, DOM measurements, and focus management.",source:"@site/docs/api/useFlash.md",sourceDirName:"api",slug:"/api/useFlash",permalink:"/docs/api/useFlash",draft:!1,unlisted:!1,editUrl:"https://github.com/refract-js/refract/tree/main/docs/docs/api/useFlash.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useOptic",permalink:"/docs/api/useOptic"},next:{title:"useLens",permalink:"/docs/api/useLens"}},o={},c=[{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"<code>effect</code>",id:"effect",level:3},{value:"<code>dependencies</code>",id:"dependencies",level:3},{value:"Return Value",id:"return-value",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"DOM Manipulation",id:"dom-manipulation",level:3},{value:"Focus Management",id:"focus-management",level:3},{value:"Animation Examples",id:"animation-examples",level:2},{value:"CSS Transitions",id:"css-transitions",level:3},{value:"JavaScript Animations",id:"javascript-animations",level:3},{value:"DOM Measurements",id:"dom-measurements",level:2},{value:"Element Dimensions",id:"element-dimensions",level:3},{value:"Scroll Position",id:"scroll-position",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Conditional Flash Effects",id:"conditional-flash-effects",level:3},{value:"Multiple Element Coordination",id:"multiple-element-coordination",level:3},{value:"Integration with Third-Party Libraries",id:"integration-with-third-party-libraries",level:2},{value:"Chart Libraries",id:"chart-libraries",level:3},{value:"Animation Libraries",id:"animation-libraries",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Avoiding Expensive Operations",id:"avoiding-expensive-operations",level:3},{value:"Testing Flash Effects",id:"testing-flash-effects",level:2},{value:"Testing DOM Manipulation",id:"testing-dom-manipulation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use for Post-Render Operations Only",id:"1-use-for-post-render-operations-only",level:3},{value:"2. Check Element Existence",id:"2-check-element-existence",level:3},{value:"3. Use Specific Dependencies",id:"3-use-specific-dependencies",level:3},{value:"4. Batch DOM Operations",id:"4-batch-dom-operations",level:3},{value:"Related APIs",id:"related-apis",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"useflash",children:"useFlash"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useFlash"})," hook executes effects after the component has rendered and the DOM has been updated. It's specifically designed for operations that need to happen after the render cycle, such as animations, DOM measurements, and focus management."]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"lens.useFlash(effect, dependencies?)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.h3,{id:"effect",children:(0,s.jsx)(n.code,{children:"effect"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," ",(0,s.jsx)(n.code,{children:"() => void"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Required:"})," Yes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," Function that contains post-render logic. Unlike ",(0,s.jsx)(n.code,{children:"useEffect"}),", flash effects cannot return cleanup functions."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencies",children:(0,s.jsx)(n.code,{children:"dependencies"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," ",(0,s.jsx)(n.code,{children:"any[] | undefined"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Required:"})," No"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," Array of values that the flash effect depends on. Effect re-runs when dependencies change."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"void"}),". Flash effects do not support cleanup functions."]}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.h3,{id:"dom-manipulation",children:"DOM Manipulation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const DOMManipulation = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const isHighlighted = lens.useRefraction(false);\n  \n  // Flash effect runs after render\n  lens.useFlash(() => {\n    if (elementRef.value && isHighlighted.value) {\n      elementRef.value.style.backgroundColor = 'yellow';\n      elementRef.value.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [isHighlighted.value]);\n  \n  return (\n    <div>\n      <button onClick={() => isHighlighted.set(!isHighlighted.value)}>\n        Toggle Highlight\n      </button>\n      <div ref={(el) => elementRef.set(el)}>\n        This element can be highlighted\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"focus-management",children:"Focus Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const FocusManagement = createComponent(({ lens }) => {\n  const inputRef = lens.useRefraction(null);\n  const shouldFocus = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (inputRef.value && shouldFocus.value) {\n      inputRef.value.focus();\n      inputRef.value.select();\n    }\n  }, [shouldFocus.value]);\n  \n  return (\n    <div>\n      <input \n        ref={(el) => inputRef.set(el)}\n        placeholder="This input can be auto-focused"\n      />\n      <button onClick={() => shouldFocus.set(true)}>\n        Focus Input\n      </button>\n    </div>\n  );\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"animation-examples",children:"Animation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"css-transitions",children:"CSS Transitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const CSSTransition = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const isVisible = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (elementRef.value) {\n      if (isVisible.value) {\n        // Trigger enter animation\n        elementRef.value.style.opacity = '0';\n        elementRef.value.style.transform = 'translateY(20px)';\n        \n        // Force reflow\n        elementRef.value.offsetHeight;\n        \n        // Apply transition\n        elementRef.value.style.transition = 'all 0.3s ease';\n        elementRef.value.style.opacity = '1';\n        elementRef.value.style.transform = 'translateY(0)';\n      }\n    }\n  }, [isVisible.value]);\n  \n  return (\n    <div>\n      <button onClick={() => isVisible.set(!isVisible.value)}>\n        Toggle Element\n      </button>\n      {isVisible.value && (\n        <div ref={(el) => elementRef.set(el)} className=\"animated-element\">\n          Animated Content\n        </div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"javascript-animations",children:"JavaScript Animations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const JSAnimation = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const animationTrigger = lens.useRefraction(0);\n  \n  lens.useFlash(() => {\n    if (elementRef.value && animationTrigger.value > 0) {\n      const element = elementRef.value;\n      const startTime = Date.now();\n      const duration = 500;\n      \n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n        \n        // Easing function\n        const easeOut = 1 - Math.pow(1 - progress, 3);\n        \n        // Apply animation\n        element.style.transform = `scale(${1 + easeOut * 0.2})`;\n        element.style.backgroundColor = `hsl(${progress * 360}, 70%, 50%)`;\n        \n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          // Reset styles\n          element.style.transform = 'scale(1)';\n          element.style.backgroundColor = '';\n        }\n      };\n      \n      requestAnimationFrame(animate);\n    }\n  }, [animationTrigger.value]);\n  \n  return (\n    <div>\n      <div ref={(el) => elementRef.set(el)} className=\"js-animated\">\n        Click the button to animate me!\n      </div>\n      <button onClick={() => animationTrigger.set(prev => prev + 1)}>\n        Animate\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dom-measurements",children:"DOM Measurements"}),"\n",(0,s.jsx)(n.h3,{id:"element-dimensions",children:"Element Dimensions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ElementMeasurement = createComponent(({ lens }) => {\n  const contentRef = lens.useRefraction(null);\n  const dimensions = lens.useRefraction({ width: 0, height: 0 });\n  const content = lens.useRefraction('Short text');\n  \n  lens.useFlash(() => {\n    if (contentRef.value) {\n      const rect = contentRef.value.getBoundingClientRect();\n      dimensions.set({\n        width: rect.width,\n        height: rect.height\n      });\n    }\n  }, [content.value]);\n  \n  const addMoreContent = () => {\n    content.set(prev => prev + ' More text added to change dimensions.');\n  };\n  \n  return (\n    <div>\n      <div ref={(el) => contentRef.set(el)} style={{ border: '1px solid #ccc', padding: '10px' }}>\n        {content.value}\n      </div>\n      <p>Dimensions: {dimensions.value.width}px \xd7 {dimensions.value.height}px</p>\n      <button onClick={addMoreContent}>Add More Content</button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scroll-position",children:"Scroll Position"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ScrollPosition = createComponent(({ lens }) => {\n  const containerRef = lens.useRefraction(null);\n  const scrollInfo = lens.useRefraction({ top: 0, left: 0 });\n  const shouldScrollToBottom = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (containerRef.value) {\n      if (shouldScrollToBottom.value) {\n        containerRef.value.scrollTop = containerRef.value.scrollHeight;\n        shouldScrollToBottom.set(false);\n      }\n      \n      // Update scroll position info\n      scrollInfo.set({\n        top: containerRef.value.scrollTop,\n        left: containerRef.value.scrollLeft\n      });\n    }\n  }, [shouldScrollToBottom.value]);\n  \n  return (\n    <div>\n      <div \n        ref={(el) => containerRef.set(el)}\n        style={{ height: '200px', overflow: 'auto', border: '1px solid #ccc' }}\n        onScroll={() => {\n          if (containerRef.value) {\n            scrollInfo.set({\n              top: containerRef.value.scrollTop,\n              left: containerRef.value.scrollLeft\n            });\n          }\n        }}\n      >\n        {Array.from({ length: 50 }, (_, i) => (\n          <div key={i} style={{ padding: '10px' }}>\n            Item {i + 1}\n          </div>\n        ))}\n      </div>\n      <p>Scroll Position: {scrollInfo.value.top}px from top</p>\n      <button onClick={() => shouldScrollToBottom.set(true)}>\n        Scroll to Bottom\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"conditional-flash-effects",children:"Conditional Flash Effects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ConditionalFlash = createComponent(({ lens, isEnabled }) => {\n  const elementRef = lens.useRefraction(null);\n  const counter = lens.useRefraction(0);\n  \n  lens.useFlash(() => {\n    // Only run flash effect when enabled\n    if (isEnabled && elementRef.value) {\n      elementRef.value.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';\n      \n      setTimeout(() => {\n        if (elementRef.value) {\n          elementRef.value.style.boxShadow = '';\n        }\n      }, 200);\n    }\n  }, [counter.value, isEnabled]);\n  \n  return (\n    <div>\n      <div ref={(el) => elementRef.set(el)} style={{ padding: '20px', border: '1px solid #ccc' }}>\n        Flash effect {isEnabled ? 'enabled' : 'disabled'}\n      </div>\n      <button onClick={() => counter.set(prev => prev + 1)}>\n        Trigger Flash ({counter.value})\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-element-coordination",children:"Multiple Element Coordination"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const MultiElementFlash = createComponent(({ lens }) => {\n  const elementsRef = lens.useRefraction([]);\n  const animationTrigger = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (animationTrigger.value && elementsRef.value.length > 0) {\n      elementsRef.value.forEach((element, index) => {\n        if (element) {\n          setTimeout(() => {\n            element.style.transform = 'scale(1.1)';\n            element.style.transition = 'transform 0.2s ease';\n            \n            setTimeout(() => {\n              element.style.transform = 'scale(1)';\n            }, 200);\n          }, index * 100);\n        }\n      });\n      \n      animationTrigger.set(false);\n    }\n  }, [animationTrigger.value]);\n  \n  const setElementRef = (index) => (el) => {\n    elementsRef.set(prev => {\n      const newRefs = [...prev];\n      newRefs[index] = el;\n      return newRefs;\n    });\n  };\n  \n  return (\n    <div>\n      <div style={{ display: 'flex', gap: '10px', margin: '20px 0' }}>\n        {Array.from({ length: 5 }, (_, i) => (\n          <div\n            key={i}\n            ref={setElementRef(i)}\n            style={{\n              width: '50px',\n              height: '50px',\n              backgroundColor: '#007bff',\n              borderRadius: '4px'\n            }}\n          />\n        ))}\n      </div>\n      <button onClick={() => animationTrigger.set(true)}>\n        Animate All Elements\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-third-party-libraries",children:"Integration with Third-Party Libraries"}),"\n",(0,s.jsx)(n.h3,{id:"chart-libraries",children:"Chart Libraries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const ChartIntegration = createComponent(({ lens, data }) => {\n  const chartRef = lens.useRefraction(null);\n  const chartInstance = lens.useRefraction(null);\n  \n  // Initialize chart after mount\n  lens.useFlash(() => {\n    if (chartRef.value && !chartInstance.value) {\n      // Initialize chart library (e.g., Chart.js)\n      const chart = new Chart(chartRef.value, {\n        type: 'line',\n        data: data,\n        options: {\n          responsive: true,\n          animation: {\n            duration: 1000\n          }\n        }\n      });\n      \n      chartInstance.set(chart);\n    }\n  }, []);\n  \n  // Update chart when data changes\n  lens.useFlash(() => {\n    if (chartInstance.value && data) {\n      chartInstance.value.data = data;\n      chartInstance.value.update('active');\n    }\n  }, [data]);\n  \n  return (\n    <div>\n      <canvas ref={(el) => chartRef.set(el)} />\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"animation-libraries",children:"Animation Libraries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const AnimationLibrary = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const shouldAnimate = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (elementRef.value && shouldAnimate.value) {\n      // Using GSAP or similar animation library\n      gsap.fromTo(elementRef.value, \n        { \n          opacity: 0, \n          y: 50 \n        },\n        { \n          opacity: 1, \n          y: 0, \n          duration: 0.5,\n          ease: "power2.out"\n        }\n      );\n      \n      shouldAnimate.set(false);\n    }\n  }, [shouldAnimate.value]);\n  \n  return (\n    <div>\n      <div ref={(el) => elementRef.set(el)}>\n        Animated with GSAP\n      </div>\n      <button onClick={() => shouldAnimate.set(true)}>\n        Animate\n      </button>\n    </div>\n  );\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"avoiding-expensive-operations",children:"Avoiding Expensive Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const PerformantFlash = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const needsUpdate = lens.useRefraction(false);\n  \n  lens.useFlash(() => {\n    if (needsUpdate.value && elementRef.value) {\n      // Use requestAnimationFrame for smooth animations\n      requestAnimationFrame(() => {\n        if (elementRef.value) {\n          // Batch DOM operations\n          elementRef.value.style.cssText = `\n            transform: translateX(100px);\n            opacity: 0.5;\n            transition: all 0.3s ease;\n          `;\n        }\n      });\n      \n      needsUpdate.set(false);\n    }\n  }, [needsUpdate.value]);\n  \n  return (\n    <div>\n      <div ref={(el) => elementRef.set(el)}>\n        Performant element\n      </div>\n      <button onClick={() => needsUpdate.set(true)}>\n        Update\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing-flash-effects",children:"Testing Flash Effects"}),"\n",(0,s.jsx)(n.h3,{id:"testing-dom-manipulation",children:"Testing DOM Manipulation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { render, act } from '@refract/testing-utils';\n\ndescribe('Flash Effects', () => {\n  test('applies styles after render', async () => {\n    const TestComponent = createComponent(({ lens }) => {\n      const elementRef = lens.useRefraction(null);\n      const trigger = lens.useRefraction(false);\n      \n      lens.useFlash(() => {\n        if (elementRef.value && trigger.value) {\n          elementRef.value.style.backgroundColor = 'red';\n        }\n      }, [trigger.value]);\n      \n      return (\n        <div>\n          <div ref={(el) => elementRef.set(el)} data-testid=\"target\">\n            Target Element\n          </div>\n          <button onClick={() => trigger.set(true)}>\n            Trigger\n          </button>\n        </div>\n      );\n    });\n    \n    const { getByTestId, getByRole } = render(<TestComponent />);\n    const targetElement = getByTestId('target');\n    \n    expect(targetElement.style.backgroundColor).toBe('');\n    \n    act(() => {\n      fireEvent.click(getByRole('button'));\n    });\n    \n    // Flash effects run after render\n    await act(async () => {\n      await new Promise(resolve => setTimeout(resolve, 0));\n    });\n    \n    expect(targetElement.style.backgroundColor).toBe('red');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-for-post-render-operations-only",children:"1. Use for Post-Render Operations Only"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - DOM manipulation after render\nlens.useFlash(() => {\n  if (elementRef.value) {\n    elementRef.value.focus();\n  }\n}, [shouldFocus]);\n\n// \u274c Bad - State updates (use useEffect instead)\nlens.useFlash(() => {\n  setState(newValue); // This should be in useEffect\n}, [trigger]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-check-element-existence",children:"2. Check Element Existence"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Always check if element exists\nlens.useFlash(() => {\n  if (elementRef.value) {\n    elementRef.value.style.color = 'red';\n  }\n}, [trigger]);\n\n// \u274c Bad - No null check\nlens.useFlash(() => {\n  elementRef.value.style.color = 'red'; // May throw error\n}, [trigger]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-use-specific-dependencies",children:"3. Use Specific Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Specific dependencies\nlens.useFlash(() => {\n  animateElement();\n}, [animationTrigger]);\n\n// \u274c Bad - Missing or too broad dependencies\nlens.useFlash(() => {\n  animateElement();\n}, []); // Missing dependency\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-batch-dom-operations",children:"4. Batch DOM Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Batch DOM operations\nlens.useFlash(() => {\n  if (elementRef.value) {\n    const element = elementRef.value;\n    element.style.cssText = `\n      transform: scale(1.1);\n      opacity: 0.8;\n      transition: all 0.3s ease;\n    `;\n  }\n}, [trigger]);\n\n// \u274c Bad - Multiple style assignments\nlens.useFlash(() => {\n  if (elementRef.value) {\n    elementRef.value.style.transform = 'scale(1.1)';\n    elementRef.value.style.opacity = '0.8';\n    elementRef.value.style.transition = 'all 0.3s ease';\n  }\n}, [trigger]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-apis",children:"Related APIs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useEffect",children:"useEffect"})})," - Side effects with cleanup support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useRefraction",children:"useRefraction"})})," - State that can trigger flash effects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./createComponent",children:"createComponent"})})," - Components that use flash effects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./useOptic",children:"useOptic"})})," - Reusable logic that may include flash effects"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(6540);const l={},a=s.createContext(l);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);