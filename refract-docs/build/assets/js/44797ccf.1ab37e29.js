"use strict";(self.webpackChunkrefract_docs=self.webpackChunkrefract_docs||[]).push([[4010],{4284:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>o});var t=s(4848),r=s(8453);const a={},c="Effects",i={id:"concepts/effects",title:"Effects",description:"Effects in Refract handle side effects and lifecycle management within components. They provide a clean, declarative way to manage asynchronous operations, subscriptions, timers, and other side effects while ensuring proper cleanup and dependency tracking.",source:"@site/docs/concepts/effects.md",sourceDirName:"concepts",slug:"/concepts/effects",permalink:"/docs/concepts/effects",draft:!1,unlisted:!1,editUrl:"https://github.com/refract-js/refract/tree/main/docs/docs/concepts/effects.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Optics",permalink:"/docs/concepts/optics"},next:{title:"API Reference Overview",permalink:"/docs/api/overview"}},l={},o=[{value:"Understanding Effects",id:"understanding-effects",level:2},{value:"Effect Types",id:"effect-types",level:2},{value:"Mount Effects",id:"mount-effects",level:3},{value:"Update Effects",id:"update-effects",level:3},{value:"Cleanup Effects",id:"cleanup-effects",level:3},{value:"Advanced Effect Patterns",id:"advanced-effect-patterns",level:2},{value:"Async Effects",id:"async-effects",level:3},{value:"Debounced Effects",id:"debounced-effects",level:3},{value:"Interval Effects",id:"interval-effects",level:3},{value:"Event Listener Effects",id:"event-listener-effects",level:3},{value:"Effect Optimization",id:"effect-optimization",level:2},{value:"Conditional Effects",id:"conditional-effects",level:3},{value:"Effect Dependencies",id:"effect-dependencies",level:3},{value:"Memoized Effects",id:"memoized-effects",level:3},{value:"Flash Effects",id:"flash-effects",level:2},{value:"Error Handling in Effects",id:"error-handling-in-effects",level:2},{value:"Try-Catch in Effects",id:"try-catch-in-effects",level:3},{value:"Error Boundaries for Effects",id:"error-boundaries-for-effects",level:3},{value:"Testing Effects",id:"testing-effects",level:2},{value:"Mocking Effects",id:"mocking-effects",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Handle Cleanup",id:"1-always-handle-cleanup",level:3},{value:"2. Use Specific Dependencies",id:"2-use-specific-dependencies",level:3},{value:"3. Handle Async Operations Safely",id:"3-handle-async-operations-safely",level:3},{value:"4. Separate Concerns",id:"4-separate-concerns",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"effects",children:"Effects"}),"\n",(0,t.jsx)(n.p,{children:"Effects in Refract handle side effects and lifecycle management within components. They provide a clean, declarative way to manage asynchronous operations, subscriptions, timers, and other side effects while ensuring proper cleanup and dependency tracking."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-effects",children:"Understanding Effects"}),"\n",(0,t.jsxs)(n.p,{children:["Effects are functions that run in response to component lifecycle events or dependency changes. They're similar to React's ",(0,t.jsx)(n.code,{children:"useEffect"})," but designed specifically for Refract's reactive system."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { createComponent } from 'refract';\n\nconst EffectExample = createComponent(({ lens }) => {\n  const data = lens.useRefraction(null);\n  \n  // Effect runs after component mounts\n  lens.useEffect(() => {\n    console.log('Component mounted');\n    \n    // Cleanup function (optional)\n    return () => {\n      console.log('Component unmounting');\n    };\n  }, []); // Empty dependency array = run once on mount\n  \n  // Effect runs when data changes\n  lens.useEffect(() => {\n    if (data.value) {\n      console.log('Data updated:', data.value);\n    }\n  }, [data.value]); // Runs when data.value changes\n  \n  return <div>Effect Example</div>;\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"effect-types",children:"Effect Types"}),"\n",(0,t.jsx)(n.h3,{id:"mount-effects",children:"Mount Effects"}),"\n",(0,t.jsx)(n.p,{children:"Run once when the component mounts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const MountEffect = createComponent(({ lens }) => {\n  const user = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    // Runs once on mount\n    fetchUserProfile().then(user.set);\n    \n    // Optional cleanup\n    return () => {\n      console.log('Cleaning up user data');\n    };\n  }, []); // Empty dependency array\n  \n  return <div>{user.value?.name || 'Loading...'}</div>;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"update-effects",children:"Update Effects"}),"\n",(0,t.jsx)(n.p,{children:"Run when specific dependencies change:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const UpdateEffect = createComponent(({ lens, userId }) => {\n  const user = lens.useRefraction(null);\n  const loading = lens.useRefraction(false);\n  \n  lens.useEffect(() => {\n    loading.set(true);\n    \n    fetchUser(userId)\n      .then(user.set)\n      .finally(() => loading.set(false));\n  }, [userId]); // Runs when userId prop changes\n  \n  return (\n    <div>\n      {loading.value ? 'Loading...' : user.value?.name}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cleanup-effects",children:"Cleanup Effects"}),"\n",(0,t.jsx)(n.p,{children:"Handle resource cleanup when components unmount or dependencies change:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const CleanupEffect = createComponent(({ lens }) => {\n  const messages = lens.useRefraction([]);\n  \n  lens.useEffect(() => {\n    // Set up subscription\n    const subscription = messageService.subscribe((message) => {\n      messages.set(prev => [...prev, message]);\n    });\n    \n    // Cleanup subscription\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n  \n  return (\n    <div>\n      {messages.value.map(msg => (\n        <div key={msg.id}>{msg.text}</div>\n      ))}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-effect-patterns",children:"Advanced Effect Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"async-effects",children:"Async Effects"}),"\n",(0,t.jsx)(n.p,{children:"Handle asynchronous operations safely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const AsyncEffect = createComponent(({ lens, searchQuery }) => {\n  const results = lens.useRefraction([]);\n  const loading = lens.useRefraction(false);\n  const error = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    if (!searchQuery) {\n      results.set([]);\n      return;\n    }\n    \n    loading.set(true);\n    error.set(null);\n    \n    // Use AbortController for cleanup\n    const abortController = new AbortController();\n    \n    const performSearch = async () => {\n      try {\n        const response = await fetch(`/api/search?q=${searchQuery}`, {\n          signal: abortController.signal\n        });\n        \n        if (!response.ok) {\n          throw new Error(`Search failed: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        // Only update if not aborted\n        if (!abortController.signal.aborted) {\n          results.set(data.results);\n        }\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          error.set(err.message);\n        }\n      } finally {\n        if (!abortController.signal.aborted) {\n          loading.set(false);\n        }\n      }\n    };\n    \n    performSearch();\n    \n    // Cleanup: abort the request\n    return () => {\n      abortController.abort();\n    };\n  }, [searchQuery]);\n  \n  return (\n    <div>\n      {loading.value && <div>Searching...</div>}\n      {error.value && <div>Error: {error.value}</div>}\n      {results.value.map(result => (\n        <div key={result.id}>{result.title}</div>\n      ))}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"debounced-effects",children:"Debounced Effects"}),"\n",(0,t.jsx)(n.p,{children:"Delay effect execution until dependencies stabilize:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const DebouncedEffect = createComponent(({ lens }) => {\n  const searchTerm = lens.useRefraction('');\n  const debouncedTerm = lens.useRefraction('');\n  const results = lens.useRefraction([]);\n  \n  // Debounce the search term\n  lens.useEffect(() => {\n    const timer = setTimeout(() => {\n      debouncedTerm.set(searchTerm.value);\n    }, 300);\n    \n    return () => clearTimeout(timer);\n  }, [searchTerm.value]);\n  \n  // Perform search when debounced term changes\n  lens.useEffect(() => {\n    if (debouncedTerm.value) {\n      performSearch(debouncedTerm.value).then(results.set);\n    } else {\n      results.set([]);\n    }\n  }, [debouncedTerm.value]);\n  \n  return (\n    <div>\n      <input\n        value={searchTerm.value}\n        onChange={(e) => searchTerm.set(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      <div>\n        {results.value.map(item => (\n          <div key={item.id}>{item.name}</div>\n        ))}\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"interval-effects",children:"Interval Effects"}),"\n",(0,t.jsx)(n.p,{children:"Handle recurring operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const IntervalEffect = createComponent(({ lens }) => {\n  const time = lens.useRefraction(new Date());\n  const isActive = lens.useRefraction(true);\n  \n  lens.useEffect(() => {\n    if (!isActive.value) return;\n    \n    const interval = setInterval(() => {\n      time.set(new Date());\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, [isActive.value]);\n  \n  return (\n    <div>\n      <p>Current time: {time.value.toLocaleTimeString()}</p>\n      <button onClick={() => isActive.set(!isActive.value)}>\n        {isActive.value ? 'Stop' : 'Start'} Clock\n      </button>\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"event-listener-effects",children:"Event Listener Effects"}),"\n",(0,t.jsx)(n.p,{children:"Manage DOM event listeners:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const EventListenerEffect = createComponent(({ lens }) => {\n  const mousePosition = lens.useRefraction({ x: 0, y: 0 });\n  const isTracking = lens.useRefraction(false);\n  \n  lens.useEffect(() => {\n    if (!isTracking.value) return;\n    \n    const handleMouseMove = (event) => {\n      mousePosition.set({\n        x: event.clientX,\n        y: event.clientY\n      });\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    \n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, [isTracking.value]);\n  \n  return (\n    <div>\n      <button onClick={() => isTracking.set(!isTracking.value)}>\n        {isTracking.value ? 'Stop' : 'Start'} Tracking\n      </button>\n      {isTracking.value && (\n        <p>Mouse: ({mousePosition.value.x}, {mousePosition.value.y})</p>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"effect-optimization",children:"Effect Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"conditional-effects",children:"Conditional Effects"}),"\n",(0,t.jsx)(n.p,{children:"Only run effects when necessary:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const ConditionalEffect = createComponent(({ lens, isEnabled, data }) => {\n  const processedData = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    // Only process data when enabled and data exists\n    if (isEnabled && data) {\n      const processed = expensiveProcessing(data);\n      processedData.set(processed);\n    } else {\n      processedData.set(null);\n    }\n  }, [isEnabled, data]); // Effect only runs when these change\n  \n  return (\n    <div>\n      {processedData.value ? (\n        <DataDisplay data={processedData.value} />\n      ) : (\n        <div>No processed data</div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"effect-dependencies",children:"Effect Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"Properly manage effect dependencies to avoid unnecessary runs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const DependencyExample = createComponent(({ lens, config }) => {\n  const data = lens.useRefraction(null);\n  \n  // \u2705 Good - Specific dependencies\n  lens.useEffect(() => {\n    fetchData(config.url, config.params).then(data.set);\n  }, [config.url, config.params]);\n  \n  // \u274c Bad - Entire object as dependency\n  // lens.useEffect(() => {\n  //   fetchData(config.url, config.params).then(data.set);\n  // }, [config]); // This runs whenever ANY config property changes\n  \n  return <div>{data.value?.title}</div>;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"memoized-effects",children:"Memoized Effects"}),"\n",(0,t.jsx)(n.p,{children:"Use memoization to prevent unnecessary effect runs:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const MemoizedEffect = createComponent(({ lens, items }) => {\n  const processedItems = lens.useRefraction([]);\n  \n  // Memoize expensive computation\n  const itemIds = lens.useDerived(() => \n    items.map(item => item.id).join(','), \n    [items]\n  );\n  \n  lens.useEffect(() => {\n    // Only runs when item IDs change, not when other item properties change\n    const processed = items.map(processItem);\n    processedItems.set(processed);\n  }, [itemIds.value]);\n  \n  return (\n    <div>\n      {processedItems.value.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"flash-effects",children:"Flash Effects"}),"\n",(0,t.jsx)(n.p,{children:"Flash effects run once after the component renders, useful for animations and DOM manipulations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const FlashEffect = createComponent(({ lens }) => {\n  const elementRef = lens.useRefraction(null);\n  const isVisible = lens.useRefraction(false);\n  \n  // Flash effect runs after render\n  lens.useFlash(() => {\n    if (elementRef.value && isVisible.value) {\n      // Animate element entrance\n      elementRef.value.style.opacity = '0';\n      elementRef.value.style.transform = 'translateY(20px)';\n      \n      requestAnimationFrame(() => {\n        elementRef.value.style.transition = 'all 0.3s ease';\n        elementRef.value.style.opacity = '1';\n        elementRef.value.style.transform = 'translateY(0)';\n      });\n    }\n  }, [isVisible.value]);\n  \n  return (\n    <div>\n      <button onClick={() => isVisible.set(!isVisible.value)}>\n        Toggle Element\n      </button>\n      {isVisible.value && (\n        <div ref={(el) => elementRef.set(el)}>\n          Animated Element\n        </div>\n      )}\n    </div>\n  );\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-in-effects",children:"Error Handling in Effects"}),"\n",(0,t.jsx)(n.h3,{id:"try-catch-in-effects",children:"Try-Catch in Effects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const ErrorHandlingEffect = createComponent(({ lens }) => {\n  const data = lens.useRefraction(null);\n  const error = lens.useRefraction(null);\n  \n  lens.useEffect(() => {\n    const loadData = async () => {\n      try {\n        error.set(null);\n        const result = await riskyAsyncOperation();\n        data.set(result);\n      } catch (err) {\n        console.error('Effect error:', err);\n        error.set(err.message);\n      }\n    };\n    \n    loadData();\n  }, []);\n  \n  if (error.value) {\n    return <div>Error: {error.value}</div>;\n  }\n  \n  return <div>{data.value || 'Loading...'}</div>;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-boundaries-for-effects",children:"Error Boundaries for Effects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const withEffectErrorBoundary = (Component) => {\n  return createComponent((props) => {\n    const { lens } = props;\n    const hasError = lens.useRefraction(false);\n    const errorMessage = lens.useRefraction('');\n    \n    // Wrap the original component with error handling\n    try {\n      if (hasError.value) {\n        return (\n          <div className=\"error-boundary\">\n            <h2>Something went wrong</h2>\n            <p>{errorMessage.value}</p>\n            <button onClick={() => hasError.set(false)}>\n              Try Again\n            </button>\n          </div>\n        );\n      }\n      \n      return <Component {...props} />;\n    } catch (error) {\n      hasError.set(true);\n      errorMessage.set(error.message);\n      return null;\n    }\n  });\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-effects",children:"Testing Effects"}),"\n",(0,t.jsx)(n.h3,{id:"mocking-effects",children:"Mocking Effects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Component with effects\nconst TimerComponent = createComponent(({ lens }) => {\n  const count = lens.useRefraction(0);\n  \n  lens.useEffect(() => {\n    const interval = setInterval(() => {\n      count.set(prev => prev + 1);\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, []);\n  \n  return <div>Count: {count.value}</div>;\n});\n\n// Test\nimport { render, act } from '@refract/testing-utils';\n\ndescribe('TimerComponent', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n  \n  afterEach(() => {\n    jest.useRealTimers();\n  });\n  \n  test('increments count every second', () => {\n    const { getByText } = render(<TimerComponent />);\n    \n    expect(getByText('Count: 0')).toBeInTheDocument();\n    \n    act(() => {\n      jest.advanceTimersByTime(1000);\n    });\n    \n    expect(getByText('Count: 1')).toBeInTheDocument();\n    \n    act(() => {\n      jest.advanceTimersByTime(2000);\n    });\n    \n    expect(getByText('Count: 3')).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-always-handle-cleanup",children:"1. Always Handle Cleanup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  const subscription = api.subscribe(handleData);\n  return () => subscription.unsubscribe();\n}, []);\n\n// \u274c Bad - No cleanup\nlens.useEffect(() => {\n  api.subscribe(handleData);\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-use-specific-dependencies",children:"2. Use Specific Dependencies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  fetchUser(userId);\n}, [userId]);\n\n// \u274c Bad - Missing dependencies\nlens.useEffect(() => {\n  fetchUser(userId);\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-handle-async-operations-safely",children:"3. Handle Async Operations Safely"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good\nlens.useEffect(() => {\n  let cancelled = false;\n  \n  fetchData().then(data => {\n    if (!cancelled) {\n      setData(data);\n    }\n  });\n  \n  return () => {\n    cancelled = true;\n  };\n}, []);\n\n// \u274c Bad - Race conditions possible\nlens.useEffect(() => {\n  fetchData().then(setData);\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-separate-concerns",children:"4. Separate Concerns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - Separate effects for different concerns\nlens.useEffect(() => {\n  // Handle user data\n  fetchUser(userId).then(setUser);\n}, [userId]);\n\nlens.useEffect(() => {\n  // Handle analytics\n  trackPageView(pageName);\n}, [pageName]);\n\n// \u274c Bad - Mixed concerns\nlens.useEffect(() => {\n  fetchUser(userId).then(setUser);\n  trackPageView(pageName);\n}, [userId, pageName]);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand effects, explore:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../api/overview",children:"API Reference"})})," - Complete API documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../tutorials/counter-app",children:"Tutorials"})})," - Practical examples using effects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../advanced/performance",children:"Advanced Topics"})})," - Performance optimization techniques"]}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var t=s(6540);const r={},a=t.createContext(r);function c(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);