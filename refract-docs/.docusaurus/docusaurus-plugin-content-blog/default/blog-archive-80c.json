{
  "blogPosts": [
    {
      "id": "performance-optimization-guide",
      "metadata": {
        "permalink": "/blog/performance-optimization-guide",
        "editUrl": "https://github.com/refract-js/refract/tree/main/docs/blog/2024-02-28-performance-optimization-guide.md",
        "source": "@site/blog/2024-02-28-performance-optimization-guide.md",
        "title": "Mastering Performance in Refract - Advanced Optimization Techniques",
        "description": "Performance is at the heart of great user experiences. While Refract provides excellent performance out of the box through its reactive architecture, understanding advanced optimization techniques can help you build lightning-fast applications that scale beautifully.",
        "date": "2024-02-28T00:00:00.000Z",
        "formattedDate": "February 28, 2024",
        "tags": [
          {
            "label": "performance",
            "permalink": "/blog/tags/performance"
          },
          {
            "label": "optimization",
            "permalink": "/blog/tags/optimization"
          },
          {
            "label": "best-practices",
            "permalink": "/blog/tags/best-practices"
          },
          {
            "label": "advanced",
            "permalink": "/blog/tags/advanced"
          }
        ],
        "readingTime": 7.25,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Refract Team",
            "title": "Core Development Team",
            "url": "https://github.com/refract-js",
            "image_url": "https://github.com/refract-js.png",
            "imageURL": "https://github.com/refract-js.png"
          }
        ],
        "frontMatter": {
          "slug": "performance-optimization-guide",
          "title": "Mastering Performance in Refract - Advanced Optimization Techniques",
          "authors": [
            {
              "name": "Refract Team",
              "title": "Core Development Team",
              "url": "https://github.com/refract-js",
              "image_url": "https://github.com/refract-js.png",
              "imageURL": "https://github.com/refract-js.png"
            }
          ],
          "tags": [
            "performance",
            "optimization",
            "best-practices",
            "advanced"
          ]
        },
        "unlisted": false,
        "nextItem": {
          "title": "Introducing Refract - A New Era of Reactive UI Development",
          "permalink": "/blog/introducing-refract"
        }
      },
      "content": "Performance is at the heart of great user experiences. While Refract provides excellent performance out of the box through its reactive architecture, understanding advanced optimization techniques can help you build lightning-fast applications that scale beautifully.\n\n<!--truncate-->\n\n## Understanding Refract's Performance Model\n\nRefract's performance advantages come from several key architectural decisions:\n\n- **Fine-grained reactivity**: Only components that depend on changed state re-render\n- **Automatic batching**: Multiple state updates are batched into single render cycles\n- **Intelligent memoization**: Derived values are cached and recomputed only when necessary\n- **Minimal overhead**: Lightweight reactive primitives with minimal runtime cost\n\n## Performance Measurement and Profiling\n\nBefore optimizing, you need to measure. Here's how to profile your Refract applications:\n\n### Built-in Performance Monitoring\n\n```javascript\nimport { createApp, enablePerformanceMonitoring } from 'refract-js';\n\n// Enable performance monitoring in development\nif (process.env.NODE_ENV === 'development') {\n  enablePerformanceMonitoring({\n    logRefractionUpdates: true,\n    logRenderTimes: true,\n    trackMemoryUsage: true,\n  });\n}\n\nconst app = createApp();\n```\n\n### Custom Performance Hooks\n\n```javascript\nconst usePerformanceTracker = createOptic((lens, componentName) => {\n  const renderCount = lens.useRefraction(0);\n  const lastRenderTime = lens.useRefraction(0);\n\n  lens.useEffect(() => {\n    const start = performance.now();\n    renderCount.set(prev => prev + 1);\n    \n    return () => {\n      const end = performance.now();\n      lastRenderTime.set(end - start);\n      \n      if (process.env.NODE_ENV === 'development') {\n        console.log(`${componentName} render #${renderCount.value}: ${end - start}ms`);\n      }\n    };\n  });\n\n  return {\n    renderCount: renderCount.value,\n    lastRenderTime: lastRenderTime.value,\n  };\n});\n```\n\n## Optimizing Refractions\n\n### 1. Minimize Refraction Granularity\n\nInstead of storing complex objects in single refractions, break them down:\n\n```javascript\n// ❌ Less optimal - entire object updates trigger all dependents\nconst user = lens.useRefraction({\n  profile: { name: 'John', email: 'john@example.com' },\n  preferences: { theme: 'dark', notifications: true },\n  stats: { loginCount: 42, lastLogin: new Date() }\n});\n\n// ✅ Better - granular updates\nconst userProfile = lens.useRefraction({ name: 'John', email: 'john@example.com' });\nconst userPreferences = lens.useRefraction({ theme: 'dark', notifications: true });\nconst userStats = lens.useRefraction({ loginCount: 42, lastLogin: new Date() });\n```\n\n### 2. Use Derived Values Strategically\n\nDerived values are cached and only recalculated when dependencies change:\n\n```javascript\nconst TodoList = createComponent(({ lens, todos }) => {\n  // ✅ Cached computation - only recalculates when todos change\n  const todoStats = lens.useDerived(() => ({\n    total: todos.value.length,\n    completed: todos.value.filter(t => t.completed).length,\n    active: todos.value.filter(t => !t.completed).length,\n  }), [todos.value]);\n\n  // ✅ Expensive filtering is cached\n  const filteredTodos = lens.useDerived(() => {\n    return todos.value\n      .filter(todo => todo.text.toLowerCase().includes(searchTerm.value.toLowerCase()))\n      .sort((a, b) => a.priority - b.priority);\n  }, [todos.value, searchTerm.value]);\n\n  return (\n    <div>\n      <TodoStats stats={todoStats.value} />\n      <TodoItems items={filteredTodos.value} />\n    </div>\n  );\n});\n```\n\n### 3. Batch State Updates\n\nWhen making multiple related updates, batch them to prevent intermediate renders:\n\n```javascript\nconst useOptimizedTodoActions = createOptic((lens, todos) => {\n  const batchUpdateTodos = (updates) => {\n    // Use a single state update for multiple changes\n    todos.set(prevTodos => {\n      let newTodos = [...prevTodos];\n      \n      updates.forEach(update => {\n        switch (update.type) {\n          case 'toggle':\n            newTodos = newTodos.map(todo =>\n              todo.id === update.id ? { ...todo, completed: !todo.completed } : todo\n            );\n            break;\n          case 'delete':\n            newTodos = newTodos.filter(todo => todo.id !== update.id);\n            break;\n          case 'add':\n            newTodos.push(update.todo);\n            break;\n        }\n      });\n      \n      return newTodos;\n    });\n  };\n\n  const completeAll = () => {\n    todos.set(prevTodos => \n      prevTodos.map(todo => ({ ...todo, completed: true }))\n    );\n  };\n\n  return { batchUpdateTodos, completeAll };\n});\n```\n\n## Component-Level Optimizations\n\n### 1. Minimize Component Re-renders\n\nUse component memoization for expensive renders:\n\n```javascript\nconst ExpensiveChart = createComponent(({ lens, data, config }) => {\n  // Only re-render when data or config actually changes\n  const memoizedChart = lens.useDerived(() => {\n    return generateChartData(data.value, config.value);\n  }, [data.value, config.value]);\n\n  // Expensive DOM operations only when necessary\n  lens.useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    renderChart(ctx, memoizedChart.value);\n  }, [memoizedChart.value]);\n\n  return <canvas ref={canvasRef} />;\n});\n```\n\n### 2. Optimize List Rendering\n\nFor large lists, implement virtualization and efficient key strategies:\n\n```javascript\nconst VirtualizedList = createComponent(({ lens, items, itemHeight = 50 }) => {\n  const scrollTop = lens.useRefraction(0);\n  const containerHeight = lens.useRefraction(400);\n\n  const visibleItems = lens.useDerived(() => {\n    const startIndex = Math.floor(scrollTop.value / itemHeight);\n    const endIndex = Math.min(\n      startIndex + Math.ceil(containerHeight.value / itemHeight) + 1,\n      items.value.length\n    );\n    \n    return items.value.slice(startIndex, endIndex).map((item, index) => ({\n      ...item,\n      index: startIndex + index,\n    }));\n  }, [scrollTop.value, containerHeight.value, items.value]);\n\n  const totalHeight = items.value.length * itemHeight;\n  const offsetY = Math.floor(scrollTop.value / itemHeight) * itemHeight;\n\n  return (\n    <div \n      style={{ height: containerHeight.value, overflow: 'auto' }}\n      onScroll={(e) => scrollTop.set(e.target.scrollTop)}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${offsetY}px)` }}>\n          {visibleItems.value.map(item => (\n            <ListItem \n              key={item.id} \n              item={item} \n              style={{ height: itemHeight }}\n            />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n});\n```\n\n### 3. Lazy Loading and Code Splitting\n\nImplement lazy loading for better initial load performance:\n\n```javascript\nconst LazyRoute = createComponent(({ lens, path, component: Component }) => {\n  const isLoaded = lens.useRefraction(false);\n  const loadedComponent = lens.useRefraction(null);\n\n  lens.useEffect(() => {\n    if (path === currentPath.value && !isLoaded.value) {\n      Component().then(module => {\n        loadedComponent.set(module.default);\n        isLoaded.set(true);\n      });\n    }\n  }, [path, currentPath.value]);\n\n  if (!isLoaded.value) {\n    return <LoadingSpinner />;\n  }\n\n  const LoadedComponent = loadedComponent.value;\n  return LoadedComponent ? <LoadedComponent lens={lens} /> : null;\n});\n\n// Usage\nconst routes = [\n  { path: '/dashboard', component: () => import('./Dashboard') },\n  { path: '/profile', component: () => import('./Profile') },\n  { path: '/settings', component: () => import('./Settings') },\n];\n```\n\n## Memory Management\n\n### 1. Cleanup Effects Properly\n\nAlways clean up subscriptions and timers:\n\n```javascript\nconst useWebSocketConnection = createOptic((lens, url) => {\n  const connection = lens.useRefraction(null);\n  const messages = lens.useRefraction([]);\n\n  lens.useEffect(() => {\n    const ws = new WebSocket(url);\n    \n    ws.onmessage = (event) => {\n      messages.set(prev => [...prev, JSON.parse(event.data)]);\n    };\n    \n    connection.set(ws);\n    \n    // Cleanup function\n    return () => {\n      ws.close();\n      connection.set(null);\n    };\n  }, [url]);\n\n  return {\n    connection: connection.value,\n    messages: messages.value,\n  };\n});\n```\n\n### 2. Avoid Memory Leaks in Derived Values\n\nBe careful with closures in derived values:\n\n```javascript\n// ❌ Potential memory leak - captures entire component scope\nconst expensiveComputation = lens.useDerived(() => {\n  return heavyProcessing(someData, anotherData, yetAnotherData);\n}, [someData.value]);\n\n// ✅ Better - only capture what's needed\nconst expensiveComputation = lens.useDerived(() => {\n  const data = someData.value;\n  return heavyProcessing(data);\n}, [someData.value]);\n```\n\n## Advanced Patterns\n\n### 1. Selective Updates with Lenses\n\nUse lenses to update specific parts of complex state:\n\n```javascript\nconst useSelectiveUpdates = createOptic((lens, initialState) => {\n  const state = lens.useRefraction(initialState);\n\n  const updatePath = (path, value) => {\n    state.set(prevState => {\n      const newState = { ...prevState };\n      let current = newState;\n      \n      for (let i = 0; i < path.length - 1; i++) {\n        current[path[i]] = { ...current[path[i]] };\n        current = current[path[i]];\n      }\n      \n      current[path[path.length - 1]] = value;\n      return newState;\n    });\n  };\n\n  return {\n    state: state.value,\n    updatePath,\n  };\n});\n```\n\n### 2. Debounced Updates\n\nImplement debouncing for expensive operations:\n\n```javascript\nconst useDebouncedSearch = createOptic((lens, delay = 300) => {\n  const query = lens.useRefraction('');\n  const debouncedQuery = lens.useRefraction('');\n  const isSearching = lens.useRefraction(false);\n\n  lens.useEffect(() => {\n    const timer = setTimeout(() => {\n      debouncedQuery.set(query.value);\n      isSearching.set(false);\n    }, delay);\n\n    isSearching.set(true);\n\n    return () => clearTimeout(timer);\n  }, [query.value, delay]);\n\n  return {\n    query: query.value,\n    debouncedQuery: debouncedQuery.value,\n    isSearching: isSearching.value,\n    setQuery: query.set,\n  };\n});\n```\n\n## Performance Monitoring in Production\n\n### 1. Custom Metrics Collection\n\n```javascript\nconst usePerformanceMetrics = createOptic((lens) => {\n  const metrics = lens.useRefraction({\n    renderCount: 0,\n    averageRenderTime: 0,\n    memoryUsage: 0,\n  });\n\n  const recordRender = (renderTime) => {\n    metrics.set(prev => ({\n      renderCount: prev.renderCount + 1,\n      averageRenderTime: (prev.averageRenderTime * prev.renderCount + renderTime) / (prev.renderCount + 1),\n      memoryUsage: performance.memory?.usedJSHeapSize || 0,\n    }));\n  };\n\n  // Send metrics to analytics service\n  lens.useEffect(() => {\n    const interval = setInterval(() => {\n      if (metrics.value.renderCount > 0) {\n        analytics.track('performance_metrics', metrics.value);\n      }\n    }, 60000); // Every minute\n\n    return () => clearInterval(interval);\n  }, []);\n\n  return { metrics: metrics.value, recordRender };\n});\n```\n\n### 2. Performance Budgets\n\nSet up performance budgets and alerts:\n\n```javascript\nconst PERFORMANCE_BUDGETS = {\n  maxRenderTime: 16, // 60fps\n  maxMemoryUsage: 50 * 1024 * 1024, // 50MB\n  maxRefractionUpdates: 100, // per second\n};\n\nconst usePerformanceBudget = createOptic((lens) => {\n  const violations = lens.useRefraction([]);\n\n  const checkBudget = (metric, value) => {\n    const budget = PERFORMANCE_BUDGETS[metric];\n    if (budget && value > budget) {\n      violations.set(prev => [...prev, {\n        metric,\n        value,\n        budget,\n        timestamp: Date.now(),\n      }]);\n\n      // Alert in development\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`Performance budget exceeded: ${metric} (${value} > ${budget})`);\n      }\n    }\n  };\n\n  return { violations: violations.value, checkBudget };\n});\n```\n\n## Best Practices Summary\n\n1. **Measure First**: Always profile before optimizing\n2. **Granular State**: Break down complex state into smaller refractions\n3. **Cache Expensive Operations**: Use derived values for computations\n4. **Batch Updates**: Group related state changes\n5. **Clean Up**: Always clean up effects and subscriptions\n6. **Virtualize Large Lists**: Implement virtualization for performance\n7. **Lazy Load**: Split code and load components on demand\n8. **Monitor Production**: Track performance metrics in production\n\n## Conclusion\n\nRefract's reactive architecture provides excellent performance out of the box, but understanding these advanced optimization techniques will help you build applications that scale to millions of users while maintaining smooth, responsive user experiences.\n\nRemember: premature optimization is the root of all evil. Focus on building great features first, then optimize based on real performance data and user feedback.\n\n---\n\n*Happy optimizing!*  \n*The Refract Team*"
    },
    {
      "id": "introducing-refract",
      "metadata": {
        "permalink": "/blog/introducing-refract",
        "editUrl": "https://github.com/refract-js/refract/tree/main/docs/blog/2024-01-15-introducing-refract.md",
        "source": "@site/blog/2024-01-15-introducing-refract.md",
        "title": "Introducing Refract - A New Era of Reactive UI Development",
        "description": "Today, we're excited to announce Refract, a revolutionary JavaScript framework that brings reactive programming to the forefront of UI development. Inspired by the physics of light refraction, Refract bends traditional paradigms to create more intuitive, performant, and maintainable applications.",
        "date": "2024-01-15T00:00:00.000Z",
        "formattedDate": "January 15, 2024",
        "tags": [
          {
            "label": "announcement",
            "permalink": "/blog/tags/announcement"
          },
          {
            "label": "reactive",
            "permalink": "/blog/tags/reactive"
          },
          {
            "label": "javascript",
            "permalink": "/blog/tags/javascript"
          },
          {
            "label": "ui",
            "permalink": "/blog/tags/ui"
          }
        ],
        "readingTime": 3.705,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Refract Team",
            "title": "Core Development Team",
            "url": "https://github.com/refract-js",
            "image_url": "https://github.com/refract-js.png",
            "imageURL": "https://github.com/refract-js.png"
          }
        ],
        "frontMatter": {
          "slug": "introducing-refract",
          "title": "Introducing Refract - A New Era of Reactive UI Development",
          "authors": [
            {
              "name": "Refract Team",
              "title": "Core Development Team",
              "url": "https://github.com/refract-js",
              "image_url": "https://github.com/refract-js.png",
              "imageURL": "https://github.com/refract-js.png"
            }
          ],
          "tags": [
            "announcement",
            "reactive",
            "javascript",
            "ui"
          ]
        },
        "unlisted": false,
        "prevItem": {
          "title": "Mastering Performance in Refract - Advanced Optimization Techniques",
          "permalink": "/blog/performance-optimization-guide"
        }
      },
      "content": "Today, we're excited to announce **Refract**, a revolutionary JavaScript framework that brings reactive programming to the forefront of UI development. Inspired by the physics of light refraction, Refract bends traditional paradigms to create more intuitive, performant, and maintainable applications.\n\n<!--truncate-->\n\n## The Problem with Current Frameworks\n\nModern web development has made tremendous strides, but we still face fundamental challenges:\n\n- **Complex State Management**: Managing application state across components remains difficult\n- **Performance Bottlenecks**: Unnecessary re-renders and inefficient updates slow down applications\n- **Developer Experience**: Steep learning curves and verbose APIs hinder productivity\n- **Composition Challenges**: Reusing logic across components often leads to complex patterns\n\n## Enter Refract: Bending Light, Bending Reality\n\nRefract addresses these challenges through a unique approach to reactive programming. Just as light bends when passing through different mediums, Refract allows your application state to flow and transform naturally through your component tree.\n\n### Core Innovations\n\n#### 1. Refractions - Reactive State Containers\n\n```javascript\nimport { createComponent } from 'refract-js';\n\nconst Counter = createComponent(({ lens }) => {\n  const count = lens.useRefraction(0);\n  \n  return (\n    <div>\n      <h1>Count: {count.value}</h1>\n      <button onClick={() => count.set(count.value + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n});\n```\n\nRefractions provide automatic dependency tracking and fine-grained updates, ensuring your UI stays in sync with minimal overhead.\n\n#### 2. Lenses - Scoped Framework Access\n\nLenses provide scoped access to framework features, ensuring clean component boundaries and predictable behavior:\n\n```javascript\nconst MyComponent = createComponent(({ lens, initialData }) => {\n  const data = lens.useRefraction(initialData);\n  const derived = lens.useDerived(() => data.value.length, [data.value]);\n  \n  lens.useEffect(() => {\n    console.log('Data changed:', data.value);\n  }, [data.value]);\n  \n  return <div>Items: {derived.value}</div>;\n});\n```\n\n#### 3. Optics - Reusable Logic Units\n\nOptics encapsulate stateful behavior that can be shared across components:\n\n```javascript\nconst useCounter = lens.useOptic((initialValue = 0) => {\n  const count = lens.useRefraction(initialValue);\n  const increment = () => count.set(prev => prev + 1);\n  const decrement = () => count.set(prev => prev - 1);\n  const reset = () => count.set(initialValue);\n  \n  return { count: count.value, increment, decrement, reset };\n});\n```\n\n## Performance That Scales\n\nRefract's reactive system ensures optimal performance through:\n\n- **Automatic Dependency Tracking**: Only components that depend on changed state re-render\n- **Batched Updates**: Multiple state changes are batched into single render cycles\n- **Intelligent Memoization**: Derived values are cached and only recalculated when dependencies change\n- **Minimal Bundle Size**: Tree-shakeable architecture keeps your bundles lean\n\n## Developer Experience First\n\nWe've designed Refract with developer productivity in mind:\n\n- **Intuitive APIs**: Natural, readable code that expresses intent clearly\n- **Excellent TypeScript Support**: Full type safety with intelligent inference\n- **Comprehensive DevTools**: Debug reactive flows with visual state inspection\n- **Rich Ecosystem**: Growing collection of utilities, patterns, and integrations\n\n## Real-World Example: Todo Application\n\nHere's how a complete todo application looks in Refract:\n\n```javascript\nconst TodoApp = createComponent(({ lens }) => {\n  const todos = lens.useRefraction([]);\n  const filter = lens.useRefraction('all');\n  const newTodo = lens.useRefraction('');\n\n  const addTodo = () => {\n    if (newTodo.value.trim()) {\n      todos.set(prev => [...prev, {\n        id: Date.now(),\n        text: newTodo.value,\n        completed: false\n      }]);\n      newTodo.set('');\n    }\n  };\n\n  const toggleTodo = (id) => {\n    todos.set(prev => prev.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ));\n  };\n\n  const filteredTodos = lens.useDerived(() => {\n    return todos.value.filter(todo => {\n      if (filter.value === 'active') return !todo.completed;\n      if (filter.value === 'completed') return todo.completed;\n      return true;\n    });\n  }, [todos.value, filter.value]);\n\n  return (\n    <div className=\"todo-app\">\n      <header>\n        <h1>Todos</h1>\n        <input\n          value={newTodo.value}\n          onChange={(e) => newTodo.set(e.target.value)}\n          onKeyPress={(e) => e.key === 'Enter' && addTodo()}\n          placeholder=\"What needs to be done?\"\n        />\n      </header>\n      \n      <main>\n        <TodoList todos={filteredTodos.value} onToggle={toggleTodo} />\n        <TodoFilters filter={filter} />\n      </main>\n    </div>\n  );\n});\n```\n\n## What's Next?\n\nThis is just the beginning. We're working on:\n\n- **Server-Side Rendering**: Full SSR support with hydration\n- **React Integration**: Gradual migration path from React applications  \n- **Mobile Development**: React Native integration for cross-platform apps\n- **Advanced DevTools**: Time-travel debugging and performance profiling\n- **Ecosystem Growth**: UI libraries, routing solutions, and state management patterns\n\n## Get Started Today\n\nReady to experience the future of reactive UI development?\n\n```bash\n# Create a new Refract app\nnpx create-refract-app my-app\ncd my-app\nnpm start\n\n# Or add to existing project\nnpm install refract-js\n```\n\nVisit our [documentation](https://refract-docs.netlify.app) for comprehensive guides, tutorials, and API references.\n\n## Join the Community\n\n- 🌟 [Star us on GitHub](https://github.com/refract-js/refract)\n- 💬 [Join our Discord](https://discord.gg/refract)\n- 🐦 [Follow us on Twitter](https://twitter.com/RefractJS)\n- 📧 [Subscribe to our newsletter](https://refract-js.org/newsletter)\n\nThe future of UI development is reactive, composable, and performant. Welcome to Refract - where light bends, and possibilities are infinite.\n\n---\n\n*The Refract Team*"
    }
  ]
}